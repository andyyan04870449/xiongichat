# 09 - 部署與監控設計文件

## 快速恢復指南
如果你忘記了這個模組，記住：這是系統的營運基礎，包含容器化部署、Kubernetes 編排、監控告警、日誌管理。重點是高可用性、自動擴展、零停機部署。

## 核心技術棧
- Docker / Kubernetes (容器化與編排)
- Prometheus + Grafana (監控)
- ELK Stack (日誌管理)
- GitHub Actions / GitLab CI (CI/CD)
- Terraform (基礎設施即程式碼)

## 專案結構
```
deployment/
├── docker/
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── .dockerignore
├── kubernetes/
│   ├── namespace.yaml
│   ├── configmap.yaml
│   ├── secrets.yaml
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   └── hpa.yaml
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── modules/
├── monitoring/
│   ├── prometheus/
│   ├── grafana/
│   └── alerts/
├── scripts/
│   ├── deploy.sh
│   ├── rollback.sh
│   └── health_check.sh
└── ci-cd/
    ├── .github/workflows/
    └── .gitlab-ci.yml
```

## 1. Docker 容器化

```dockerfile
# docker/Dockerfile
# 多階段建構
FROM python:3.11-slim as builder

# 設定工作目錄
WORKDIR /app

# 安裝系統依賴
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# 複製需求檔案
COPY requirements.txt .

# 安裝 Python 套件
RUN pip install --no-cache-dir --user -r requirements.txt

# 執行階段
FROM python:3.11-slim

# 設定非 root 使用者
RUN useradd -m -u 1000 appuser

WORKDIR /app

# 安裝執行時依賴
RUN apt-get update && apt-get install -y \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 複製 Python 套件
COPY --from=builder /root/.local /home/appuser/.local

# 複製應用程式碼
COPY --chown=appuser:appuser . .

# 設定環境變數
ENV PATH=/home/appuser/.local/bin:$PATH \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PORT=8000

# 切換到非 root 使用者
USER appuser

# 健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/api/v1/healthz || exit 1

# 暴露端口
EXPOSE 8000

# 啟動命令
CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

```yaml
# docker/docker-compose.yml
version: '3.8'

services:
  # PostgreSQL 資料庫
  postgres:
    image: pgvector/pgvector:pg15
    environment:
      POSTGRES_DB: xiongichat
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_EXTENSIONS: pgvector
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app_network

  # Redis 快取
  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app_network

  # 應用程式
  app:
    build:
      context: .
      dockerfile: docker/Dockerfile
    environment:
      DATABASE_URL: postgresql://postgres:${DB_PASSWORD}@postgres:5432/xiongichat
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      SECRET_KEY: ${SECRET_KEY}
      ENVIRONMENT: production
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "8000:8000"
    volumes:
      - ./logs:/app/logs
    networks:
      - app_network
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./certs:/etc/nginx/certs
    ports:
      - "443:443"
      - "80:80"
    depends_on:
      - app
    networks:
      - app_network

volumes:
  postgres_data:
  redis_data:

networks:
  app_network:
    driver: bridge
```

## 2. Kubernetes 部署

```yaml
# kubernetes/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: xiongichat
  labels:
    name: xiongichat
    environment: production
```

```yaml
# kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xiongichat-api
  namespace: xiongichat
  labels:
    app: xiongichat-api
    version: v1
spec:
  replicas: 3
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: xiongichat-api
  template:
    metadata:
      labels:
        app: xiongichat-api
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: xiongichat-sa
      
      # 安全設定
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      
      # Init Container - 資料庫遷移
      initContainers:
      - name: db-migration
        image: xiongichat:latest
        command: ["alembic", "upgrade", "head"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: xiongichat-secrets
              key: database-url
      
      containers:
      - name: api
        image: xiongichat:latest
        imagePullPolicy: Always
        
        ports:
        - name: http
          containerPort: 8000
          protocol: TCP
        
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: xiongichat-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: xiongichat-secrets
              key: redis-url
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: xiongichat-secrets
              key: openai-api-key
        
        # 資源限制
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        
        # 健康檢查
        livenessProbe:
          httpGet:
            path: /api/v1/healthz
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /api/v1/ready
            port: http
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        
        # 掛載
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
        - name: logs
          mountPath: /app/logs
      
      volumes:
      - name: config
        configMap:
          name: xiongichat-config
      - name: logs
        emptyDir: {}
      
      # Pod 親和性
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - xiongichat-api
              topologyKey: kubernetes.io/hostname
```

```yaml
# kubernetes/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: xiongichat-api-hpa
  namespace: xiongichat
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: xiongichat-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: 1000
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max
```

## 3. CI/CD 管線

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run tests
      run: |
        pytest tests/ --cov=api --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
    
    - name: Security scan
      run: |
        pip install bandit safety
        bandit -r api/
        safety check
  
  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Image security scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to Kubernetes
      run: |
        # 更新 image tag
        kubectl set image deployment/xiongichat-api \
          api=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          -n xiongichat
        
        # 等待部署完成
        kubectl rollout status deployment/xiongichat-api -n xiongichat
    
    - name: Verify deployment
      run: |
        kubectl get pods -n xiongichat
        kubectl get services -n xiongichat
    
    - name: Run smoke tests
      run: |
        API_URL=$(kubectl get service xiongichat-api -n xiongichat -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        curl -f http://$API_URL/api/v1/healthz || exit 1
    
    - name: Notify deployment
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: 'Deployment to production ${{ job.status }}'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

## 4. Prometheus 監控

```yaml
# monitoring/prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    cluster: 'production'
    service: 'xiongichat'

scrape_configs:
  # 應用程式指標
  - job_name: 'xiongichat-api'
    kubernetes_sd_configs:
    - role: pod
      namespaces:
        names:
        - xiongichat
    relabel_configs:
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
      action: keep
      regex: true
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
      action: replace
      target_label: __metrics_path__
      regex: (.+)
    - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
      action: replace
      regex: ([^:]+)(?::\d+)?;(\d+)
      replacement: $1:$2
      target_label: __address__
    - action: labelmap
      regex: __meta_kubernetes_pod_label_(.+)
    
  # PostgreSQL 監控
  - job_name: 'postgres'
    static_configs:
    - targets: ['postgres-exporter:9187']
    
  # Redis 監控
  - job_name: 'redis'
    static_configs:
    - targets: ['redis-exporter:9121']

# 告警規則
rule_files:
  - '/etc/prometheus/alerts/*.yml'

# Alertmanager 配置
alerting:
  alertmanagers:
  - static_configs:
    - targets: ['alertmanager:9093']
```

```yaml
# monitoring/prometheus/alerts/app_alerts.yml
groups:
- name: xiongichat_alerts
  interval: 30s
  rules:
  
  # API 可用性
  - alert: APIDown
    expr: up{job="xiongichat-api"} == 0
    for: 2m
    labels:
      severity: critical
      team: backend
    annotations:
      summary: "API 服務不可用"
      description: "{{ $labels.instance }} 已經離線超過 2 分鐘"
  
  # 高錯誤率
  - alert: HighErrorRate
    expr: |
      rate(http_requests_total{status=~"5.."}[5m]) > 0.05
    for: 5m
    labels:
      severity: warning
      team: backend
    annotations:
      summary: "API 錯誤率過高"
      description: "5xx 錯誤率超過 5%: {{ $value | humanizePercentage }}"
  
  # 高延遲
  - alert: HighLatency
    expr: |
      histogram_quantile(0.95, 
        rate(http_request_duration_seconds_bucket[5m])
      ) > 1
    for: 5m
    labels:
      severity: warning
      team: backend
    annotations:
      summary: "API 延遲過高"
      description: "P95 延遲超過 1 秒: {{ $value }}s"
  
  # 記憶體使用
  - alert: HighMemoryUsage
    expr: |
      container_memory_usage_bytes{pod=~"xiongichat-api-.*"} 
      / container_spec_memory_limit_bytes > 0.9
    for: 5m
    labels:
      severity: warning
      team: backend
    annotations:
      summary: "記憶體使用率過高"
      description: "Pod {{ $labels.pod }} 記憶體使用超過 90%"
  
  # 資料庫連線
  - alert: DatabaseConnectionPoolExhausted
    expr: |
      pg_stat_database_numbackends{datname="xiongichat"} 
      / pg_settings_max_connections > 0.8
    for: 5m
    labels:
      severity: warning
      team: database
    annotations:
      summary: "資料庫連線池即將耗盡"
      description: "已使用 {{ $value | humanizePercentage }} 的連線"
  
  # 風險事件
  - alert: HighRiskEventDetected
    expr: |
      increase(risk_events_total{level="IMMINENT"}[5m]) > 0
    labels:
      severity: critical
      team: crisis
    annotations:
      summary: "偵測到高風險事件"
      description: "5分鐘內發生 {{ $value }} 起危急風險事件"
```

## 5. Grafana 儀表板

```json
{
  "dashboard": {
    "title": "雄i聊系統監控",
    "panels": [
      {
        "title": "API QPS",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])",
            "legendFormat": "{{method}} {{path}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "延遲分佈",
        "targets": [
          {
            "expr": "histogram_quantile(0.5, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "P50"
          },
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "P95"
          },
          {
            "expr": "histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "P99"
          }
        ],
        "type": "graph"
      },
      {
        "title": "錯誤率",
        "targets": [
          {
            "expr": "rate(http_requests_total{status=~\"5..\"}[5m])",
            "legendFormat": "5xx Errors"
          },
          {
            "expr": "rate(http_requests_total{status=~\"4..\"}[5m])",
            "legendFormat": "4xx Errors"
          }
        ],
        "type": "graph"
      },
      {
        "title": "活躍使用者",
        "targets": [
          {
            "expr": "count(increase(user_activity_total[5m]) > 0)",
            "legendFormat": "Active Users"
          }
        ],
        "type": "stat"
      },
      {
        "title": "風險事件",
        "targets": [
          {
            "expr": "sum by (level) (increase(risk_events_total[1h]))",
            "legendFormat": "{{level}}"
          }
        ],
        "type": "piechart"
      },
      {
        "title": "資料庫效能",
        "targets": [
          {
            "expr": "pg_stat_database_tup_fetched{datname=\"xiongichat\"}",
            "legendFormat": "Rows Fetched"
          },
          {
            "expr": "pg_stat_database_tup_inserted{datname=\"xiongichat\"}",
            "legendFormat": "Rows Inserted"
          }
        ],
        "type": "graph"
      }
    ]
  }
}
```

## 6. ELK 日誌管理

```yaml
# monitoring/elk/logstash.conf
input {
  # 從 Kubernetes 收集日誌
  kubernetes {
    pod_name => "xiongichat-api-*"
    namespace => "xiongichat"
  }
  
  # 從檔案收集
  file {
    path => "/var/log/xiongichat/*.log"
    start_position => "beginning"
    codec => "json"
  }
}

filter {
  # 解析 JSON 日誌
  json {
    source => "message"
  }
  
  # 加入地理位置資訊
  geoip {
    source => "client_ip"
    target => "geoip"
  }
  
  # 解析 User Agent
  useragent {
    source => "user_agent"
    target => "ua"
  }
  
  # 提取關鍵欄位
  mutate {
    add_field => {
      "[@metadata][target_index]" => "xiongichat-%{+YYYY.MM.dd}"
    }
  }
  
  # 過濾敏感資訊
  mutate {
    gsub => [
      "message", "\b[A-Z][12]\d{8}\b", "[REDACTED_ID]",
      "message", "\b09\d{8}\b", "[REDACTED_PHONE]"
    ]
  }
}

output {
  # 輸出到 Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][target_index]}"
    template_name => "xiongichat"
    template => "/etc/logstash/templates/xiongichat.json"
  }
  
  # 高風險事件即時告警
  if [risk_level] == "IMMINENT" {
    email {
      to => "crisis-team@kao.gov.tw"
      subject => "緊急風險事件 - %{user_id}"
      body => "偵測到危急風險事件\n用戶: %{user_id}\n時間: %{@timestamp}\n內容: %{message}"
    }
  }
}
```

## 7. 健康檢查與自動恢復

```python
# scripts/health_check.py
import asyncio
import aiohttp
from typing import Dict, List
import logging
from datetime import datetime

class HealthChecker:
    """健康檢查器"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.checks = {
            "api": self._check_api,
            "database": self._check_database,
            "redis": self._check_redis,
            "ml_service": self._check_ml_service
        }
    
    async def run_checks(self) -> Dict:
        """執行所有健康檢查"""
        
        results = {
            "timestamp": datetime.utcnow().isoformat(),
            "status": "healthy",
            "checks": {}
        }
        
        # 平行執行檢查
        tasks = {
            name: check() 
            for name, check in self.checks.items()
        }
        
        check_results = await asyncio.gather(
            *tasks.values(),
            return_exceptions=True
        )
        
        # 處理結果
        for (name, _), result in zip(tasks.items(), check_results):
            if isinstance(result, Exception):
                results["checks"][name] = {
                    "status": "unhealthy",
                    "error": str(result)
                }
                results["status"] = "degraded"
            else:
                results["checks"][name] = result
                if result["status"] != "healthy":
                    results["status"] = "degraded"
        
        # 觸發自動恢復
        if results["status"] != "healthy":
            await self._trigger_recovery(results)
        
        return results
    
    async def _check_api(self) -> Dict:
        """檢查 API 健康"""
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{self.config['api_url']}/api/v1/healthz"
                
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        data = await response.json()
                        return {
                            "status": "healthy",
                            "response_time": response.headers.get("X-Response-Time"),
                            "version": data.get("version")
                        }
                    else:
                        return {
                            "status": "unhealthy",
                            "http_status": response.status
                        }
        
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }
    
    async def _check_database(self) -> Dict:
        """檢查資料庫健康"""
        
        try:
            # 執行簡單查詢
            async with self.get_db_connection() as conn:
                result = await conn.fetchone("SELECT 1")
                
                # 檢查連線池
                pool_stats = await conn.fetchone("""
                    SELECT 
                        count(*) as total_connections,
                        count(*) FILTER (WHERE state = 'active') as active,
                        count(*) FILTER (WHERE state = 'idle') as idle
                    FROM pg_stat_activity
                    WHERE datname = 'xiongichat'
                """)
                
                return {
                    "status": "healthy",
                    "connections": {
                        "total": pool_stats["total_connections"],
                        "active": pool_stats["active"],
                        "idle": pool_stats["idle"]
                    }
                }
        
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }
    
    async def _check_redis(self) -> Dict:
        """檢查 Redis 健康"""
        
        try:
            redis = await aioredis.from_url(
                self.config["redis_url"]
            )
            
            # PING 測試
            pong = await redis.ping()
            
            # 取得資訊
            info = await redis.info()
            
            await redis.close()
            
            return {
                "status": "healthy" if pong else "unhealthy",
                "memory_used": info.get("used_memory_human"),
                "connected_clients": info.get("connected_clients")
            }
        
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }
    
    async def _check_ml_service(self) -> Dict:
        """檢查 ML 服務健康"""
        
        try:
            # 測試嵌入生成
            test_text = "健康檢查測試"
            embedding = await self.embedder.embed_text(test_text)
            
            if len(embedding) == 1536:
                return {
                    "status": "healthy",
                    "model": "text-embedding-3-small"
                }
            else:
                return {
                    "status": "degraded",
                    "issue": "unexpected_embedding_dimension"
                }
        
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }
    
    async def _trigger_recovery(self, health_results: Dict):
        """觸發自動恢復"""
        
        for check_name, result in health_results["checks"].items():
            if result["status"] != "healthy":
                self.logger.warning(
                    f"Triggering recovery for {check_name}: {result}"
                )
                
                if check_name == "api":
                    # 重啟 API pods
                    await self._restart_pods("xiongichat-api")
                
                elif check_name == "database":
                    # 清理連線池
                    await self._cleanup_db_connections()
                
                elif check_name == "redis":
                    # 清理過期 keys
                    await self._cleanup_redis()
    
    async def _restart_pods(self, deployment_name: str):
        """重啟 Kubernetes pods"""
        
        import subprocess
        
        cmd = f"kubectl rollout restart deployment/{deployment_name} -n xiongichat"
        
        result = subprocess.run(
            cmd.split(),
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            self.logger.info(f"Successfully restarted {deployment_name}")
        else:
            self.logger.error(f"Failed to restart {deployment_name}: {result.stderr}")
```

## 8. 災難恢復

```bash
#!/bin/bash
# scripts/disaster_recovery.sh

set -e

# 設定變數
NAMESPACE="xiongichat"
BACKUP_DIR="/backup"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# 函數：備份資料庫
backup_database() {
    echo "備份資料庫..."
    
    kubectl exec -n $NAMESPACE postgres-0 -- \
        pg_dump -U postgres xiongichat | \
        gzip > $BACKUP_DIR/db_backup_$TIMESTAMP.sql.gz
    
    echo "資料庫備份完成: db_backup_$TIMESTAMP.sql.gz"
}

# 函數：備份 Redis
backup_redis() {
    echo "備份 Redis..."
    
    kubectl exec -n $NAMESPACE redis-0 -- \
        redis-cli --rdb /tmp/dump.rdb BGSAVE
    
    sleep 5
    
    kubectl cp $NAMESPACE/redis-0:/tmp/dump.rdb \
        $BACKUP_DIR/redis_backup_$TIMESTAMP.rdb
    
    echo "Redis 備份完成: redis_backup_$TIMESTAMP.rdb"
}

# 函數：備份設定
backup_configs() {
    echo "備份 Kubernetes 設定..."
    
    kubectl get all,cm,secret,pvc,pv -n $NAMESPACE \
        -o yaml > $BACKUP_DIR/k8s_resources_$TIMESTAMP.yaml
    
    echo "設定備份完成: k8s_resources_$TIMESTAMP.yaml"
}

# 函數：恢復資料庫
restore_database() {
    local BACKUP_FILE=$1
    
    echo "恢復資料庫從: $BACKUP_FILE"
    
    gunzip < $BACKUP_FILE | \
        kubectl exec -i -n $NAMESPACE postgres-0 -- \
        psql -U postgres xiongichat
    
    echo "資料庫恢復完成"
}

# 函數：恢復 Redis
restore_redis() {
    local BACKUP_FILE=$1
    
    echo "恢復 Redis 從: $BACKUP_FILE"
    
    kubectl cp $BACKUP_FILE $NAMESPACE/redis-0:/tmp/dump.rdb
    
    kubectl exec -n $NAMESPACE redis-0 -- \
        redis-cli SHUTDOWN NOSAVE
    
    kubectl exec -n $NAMESPACE redis-0 -- \
        mv /tmp/dump.rdb /data/dump.rdb
    
    kubectl delete pod redis-0 -n $NAMESPACE
    
    echo "Redis 恢復完成"
}

# 函數：健康檢查
health_check() {
    echo "執行健康檢查..."
    
    # API 健康檢查
    API_URL=$(kubectl get svc xiongichat-api -n $NAMESPACE \
        -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    
    if curl -f http://$API_URL/api/v1/healthz; then
        echo "API 健康檢查通過"
    else
        echo "API 健康檢查失敗"
        exit 1
    fi
}

# 主程式
case "$1" in
    backup)
        backup_database
        backup_redis
        backup_configs
        ;;
    restore)
        if [ -z "$2" ]; then
            echo "用法: $0 restore <timestamp>"
            exit 1
        fi
        
        restore_database "$BACKUP_DIR/db_backup_$2.sql.gz"
        restore_redis "$BACKUP_DIR/redis_backup_$2.rdb"
        health_check
        ;;
    health)
        health_check
        ;;
    *)
        echo "用法: $0 {backup|restore|health}"
        exit 1
        ;;
esac
```

## 9. Terraform 基礎設施

```hcl
# terraform/main.tf
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
  
  backend "gcs" {
    bucket = "xiongichat-terraform-state"
    prefix = "terraform/state"
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

# GKE 叢集
resource "google_container_cluster" "xiongichat" {
  name     = "xiongichat-cluster"
  location = var.region
  
  initial_node_count = 3
  
  node_config {
    machine_type = "n2-standard-4"
    
    oauth_scopes = [
      "https://www.googleapis.com/auth/cloud-platform"
    ]
    
    labels = {
      environment = "production"
      service     = "xiongichat"
    }
    
    tags = ["xiongichat-node"]
  }
  
  # 自動擴展
  cluster_autoscaling {
    enabled = true
    
    resource_limits {
      resource_type = "cpu"
      minimum       = 4
      maximum       = 100
    }
    
    resource_limits {
      resource_type = "memory"
      minimum       = 16
      maximum       = 400
    }
  }
  
  # 網路政策
  network_policy {
    enabled = true
  }
  
  # 監控
  monitoring_config {
    enable_components = ["SYSTEM_COMPONENTS", "WORKLOADS"]
  }
}

# Cloud SQL (PostgreSQL)
resource "google_sql_database_instance" "postgres" {
  name             = "xiongichat-postgres"
  database_version = "POSTGRES_15"
  region           = var.region
  
  settings {
    tier = "db-custom-4-16384"
    
    disk_config {
      size = 100
      type = "PD_SSD"
    }
    
    backup_configuration {
      enabled    = true
      start_time = "02:00"
      
      backup_retention_settings {
        retained_backups = 30
        retention_unit   = "COUNT"
      }
    }
    
    ip_configuration {
      ipv4_enabled    = true
      private_network = google_compute_network.vpc.id
      
      authorized_networks {
        name  = "gke-cluster"
        value = google_container_cluster.xiongichat.endpoint
      }
    }
    
    database_flags {
      name  = "max_connections"
      value = "200"
    }
    
    database_flags {
      name  = "shared_preload_libraries"
      value = "pg_stat_statements,pgvector"
    }
  }
}

# Redis (Memorystore)
resource "google_redis_instance" "cache" {
  name           = "xiongichat-redis"
  tier           = "STANDARD_HA"
  memory_size_gb = 5
  region         = var.region
  
  redis_version = "REDIS_6_X"
  
  redis_configs = {
    maxmemory-policy = "allkeys-lru"
  }
  
  auth_enabled = true
}

# 負載平衡器
resource "google_compute_global_address" "api_ip" {
  name = "xiongichat-api-ip"
}

# SSL 憑證
resource "google_compute_managed_ssl_certificate" "api_cert" {
  name = "xiongichat-api-cert"
  
  managed {
    domains = ["api.xiongichat.kao.gov.tw"]
  }
}

# 監控告警
resource "google_monitoring_alert_policy" "api_uptime" {
  display_name = "API Uptime Alert"
  
  conditions {
    display_name = "API is down"
    
    condition_threshold {
      filter          = "metric.type=\"compute.googleapis.com/instance/uptime\" resource.type=\"gce_instance\""
      duration        = "60s"
      comparison      = "COMPARISON_LT"
      threshold_value = 1
    }
  }
  
  notification_channels = [
    google_monitoring_notification_channel.email.name
  ]
}

output "cluster_endpoint" {
  value = google_container_cluster.xiongichat.endpoint
}

output "database_connection" {
  value     = google_sql_database_instance.postgres.connection_name
  sensitive = true
}
```

## 關鍵記憶點
1. **必須**實作零停機部署策略 (Rolling Update)
2. **記得**設定資源限制避免資源耗盡
3. **注意**監控告警要分級處理
4. **重要**定期執行災難恢復演練