# 脫敏資料閱讀指南 [暫緩實作]

## ⚠️ 注意：此功能暫緩實作
根據最新決定，脫敏機制暫時不實作。此文件保留作為未來參考。

## 脫敏資料的呈現方式

### 1. 常見脫敏格式範例

```text
原始訊息：
「我是王大明，身分證A123456789，住在高雄市前金區中正四路211號，
電話0912345678，我最近在服用美沙冬，有憂鬱症病史。」

脫敏後：
「我是王○○，身分證[身分證]，住在[地址]，
電話09XX-XXX-XXX，我最近在服用美沙*，有[醫療資訊]病史。」
```

### 2. 脫敏標記對照表

| 脫敏標記 | 實際含義 | 範例 | 閱讀方式 |
|---------|---------|------|----------|
| `○○` | 姓名（保留姓） | 王○○ | 知道姓氏為王 |
| `[身分證]` | 身分證字號 | [身分證] | 有提供身分證但已遮蔽 |
| `[地址]` | 完整地址 | [地址] | 有提供地址資訊 |
| `09XX-XXX-XXX` | 手機號碼 | 09XX-XXX-XXX | 知道是09開頭手機 |
| `[email]` | 電子郵件 | [email] | 有email資訊 |
| `[醫療資訊]` | 醫療敏感詞 | [醫療資訊] | 涉及醫療隱私 |
| `***` | 部分遮蔽 | 美沙* | 保留關鍵字首 |
| `[藥物俗稱]` | 毒品相關詞彙 | [藥物俗稱] | 提到藥物俗稱 |
| `XXXX-XXXX-XXXX-XXXX` | 信用卡號 | XXXX-XXXX-XXXX-XXXX | 有金融資訊 |

## 脫敏資料的閱讀介面

### 1. 管理後台檢視

```typescript
// React 元件範例
interface RedactedMessage {
  content_redacted: string;
  redaction_metadata: {
    items_found: number;
    categories: string[];
    has_high_risk: boolean;
  };
}

function MessageViewer({ message }: { message: RedactedMessage }) {
  return (
    <div className="message-container">
      {/* 脫敏內容顯示 */}
      <div className="redacted-content">
        {highlightRedactions(message.content_redacted)}
      </div>
      
      {/* 脫敏統計資訊 */}
      <div className="redaction-info">
        <Badge>已脫敏 {message.redaction_metadata.items_found} 項</Badge>
        {message.redaction_metadata.categories.map(cat => (
          <Tag key={cat}>{getCategoryName(cat)}</Tag>
        ))}
      </div>
      
      {/* 風險提示 */}
      {message.redaction_metadata.has_high_risk && (
        <Alert type="warning">此訊息包含高風險內容</Alert>
      )}
    </div>
  );
}

// 高亮顯示脫敏部分
function highlightRedactions(text: string) {
  return text.split(/(\[[\u4e00-\u9fa5]+\]|○+|X+)/g).map((part, i) => {
    if (part.match(/\[[\u4e00-\u9fa5]+\]|○+|X+/)) {
      return <span key={i} className="redacted-highlight">{part}</span>;
    }
    return part;
  });
}
```

### 2. 脫敏資料視覺化

```css
/* 脫敏內容樣式 */
.redacted-highlight {
  background-color: #ffd700;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: bold;
  cursor: help;
  position: relative;
}

.redacted-highlight:hover::after {
  content: attr(data-type);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  white-space: nowrap;
  font-size: 12px;
}
```

## 不同角色的閱讀權限

### 1. 一般管理員視圖

```python
class AdminMessageView:
    """一般管理員看到的訊息"""
    
    def format_for_admin(self, message):
        return {
            "id": message.id,
            "user_id": self.hash_user_id(message.user_id),  # 假名化
            "content": message.content_redacted,  # 脫敏版
            "risk_level": message.risk_level,
            "created_at": message.created_at,
            
            # 提供脫敏統計
            "redaction_summary": {
                "total_redacted": len(message.redaction_metadata["items"]),
                "categories": message.redaction_metadata["categories"],
                "severity": self.calculate_severity(message.redaction_metadata)
            },
            
            # 不提供原文連結
            "can_view_original": False
        }
```

### 2. 危機處理團隊視圖

```python
class CrisisTeamView:
    """危機團隊的特殊檢視權限"""
    
    def format_for_crisis_team(self, message, risk_assessment):
        base_view = {
            "id": message.id,
            "user_id": message.user_id,  # 真實 ID
            "content": message.content_redacted,
            "risk_assessment": risk_assessment,
            
            # 顯示風險關鍵字（部分還原）
            "risk_keywords": self.extract_risk_keywords(message),
            
            # 提供關鍵上下文
            "context_summary": self.generate_context_summary(message),
            
            # 可申請查看原文
            "can_request_original": True,
            "request_original_url": f"/api/crisis/request-original/{message.id}"
        }
        
        # 如果是緊急情況，提供更多資訊
        if risk_assessment.level == "IMMINENT":
            base_view["emergency_context"] = {
                "last_known_location": self.get_redacted_location(message),
                "contact_method": self.get_safe_contact(message.user_id),
                "recent_pattern": self.get_risk_pattern(message.user_id)
            }
        
        return base_view
```

### 3. 資料分析師視圖

```python
class AnalystView:
    """資料分析師的統計視圖"""
    
    def format_for_analyst(self, messages):
        return {
            # 完全匿名化的統計資料
            "total_messages": len(messages),
            "risk_distribution": self.calculate_risk_distribution(messages),
            
            # 脫敏類別統計
            "redaction_statistics": {
                "pii": self.count_category(messages, "pii"),
                "medical": self.count_category(messages, "medical"),
                "contact": self.count_category(messages, "contact"),
                "location": self.count_category(messages, "location")
            },
            
            # 趨勢分析（不含個人資訊）
            "trends": {
                "risk_trend": self.calculate_trend(messages, "risk"),
                "topic_distribution": self.get_topics_without_pii(messages)
            },
            
            # 不提供個別訊息
            "messages": None
        }
```

## 申請查看原文的流程

### 1. 申請介面

```typescript
// 申請查看原文的表單
interface OriginalContentRequest {
  message_id: string;
  reason: string;
  purpose: 'crisis_intervention' | 'legal_requirement' | 'medical_assessment';
  urgency: 'immediate' | 'urgent' | 'normal';
  requester_id: string;
  supervisor_approval?: string;
}

async function requestOriginalContent(request: OriginalContentRequest) {
  // 1. 驗證權限
  if (!hasPermission(request.requester_id, 'request_original')) {
    throw new Error('無權限申請查看原文');
  }
  
  // 2. 檢查是否需要主管核准
  if (request.urgency !== 'immediate') {
    if (!request.supervisor_approval) {
      return { status: 'pending_approval', approval_id: generateApprovalId() };
    }
  }
  
  // 3. 記錄審計
  await auditLog.record({
    action: 'request_original_content',
    requester: request.requester_id,
    message_id: request.message_id,
    reason: request.reason,
    timestamp: new Date()
  });
  
  // 4. 生成限時連結
  const temporaryUrl = generateTemporaryUrl(request.message_id, {
    expires_in: 300,  // 5分鐘有效
    single_use: true,  // 一次性連結
    watermark: request.requester_id  // 浮水印
  });
  
  return { status: 'approved', url: temporaryUrl };
}
```

### 2. 原文檢視介面

```python
@router.get("/secure/original/{token}")
async def view_original_content(
    token: str,
    request: Request
):
    """查看原文的安全介面"""
    
    # 1. 驗證 token
    token_data = verify_temporary_token(token)
    if not token_data or token_data["expired"]:
        raise HTTPException(403, "連結已失效")
    
    # 2. 二次身份驗證
    if not await verify_mfa(request):
        raise HTTPException(403, "需要二次驗證")
    
    # 3. 取得並解密原文
    message = await db.get_message(token_data["message_id"])
    original_content = await decrypt(message.content_encrypted)
    
    # 4. 加入檢視標記
    watermarked_content = add_watermark(
        original_content,
        viewer_id=token_data["requester_id"],
        timestamp=datetime.utcnow()
    )
    
    # 5. 記錄檢視事件
    await audit_log.record_view({
        "viewer": token_data["requester_id"],
        "message_id": token_data["message_id"],
        "ip": request.client.host,
        "timestamp": datetime.utcnow()
    })
    
    # 6. 標記 token 已使用
    await mark_token_used(token)
    
    return {
        "content": watermarked_content,
        "viewer_id": token_data["requester_id"],
        "viewed_at": datetime.utcnow(),
        "warning": "此內容包含敏感資訊，請勿截圖或外流"
    }
```

## 脫敏資料的搜尋功能

### 1. 模糊搜尋

```python
class RedactedSearch:
    """在脫敏資料中搜尋"""
    
    def search(self, query: str, messages: List[Message]):
        # 將搜尋詞也進行相同的脫敏處理
        redacted_query = self.redactor.redact(query).redacted
        
        results = []
        for message in messages:
            # 在脫敏內容中搜尋
            if self.fuzzy_match(redacted_query, message.content_redacted):
                results.append({
                    "message_id": message.id,
                    "matched_content": self.highlight_match(
                        message.content_redacted,
                        redacted_query
                    ),
                    "score": self.calculate_match_score(
                        redacted_query,
                        message.content_redacted
                    )
                })
        
        return sorted(results, key=lambda x: x["score"], reverse=True)
    
    def fuzzy_match(self, query: str, content: str) -> bool:
        """模糊匹配，考慮脫敏標記"""
        # 將脫敏標記轉為通配符
        pattern = query.replace("[", r"\[").replace("]", r"\]")
        pattern = pattern.replace("○○", ".{2}")
        pattern = pattern.replace("XXX", ".{3}")
        
        return bool(re.search(pattern, content, re.IGNORECASE))
```

### 2. 語意搜尋

```python
async def semantic_search_redacted(query: str):
    """在脫敏資料上進行語意搜尋"""
    
    # 1. 將查詢向量化
    query_embedding = await embedder.embed(query)
    
    # 2. 搜尋向量資料庫（向量是基於脫敏內容生成的）
    results = await vector_db.search(
        query_embedding,
        filter={"is_redacted": True}
    )
    
    # 3. 返回脫敏結果
    return [
        {
            "content": r.content_redacted,
            "relevance": r.score,
            "metadata": {
                "has_pii": r.redaction_metadata["items_found"] > 0,
                "risk_level": r.risk_level
            }
        }
        for r in results
    ]
```

## 脫敏資料的匯出格式

### 1. CSV 匯出

```csv
訊息ID,時間,使用者(匿名),內容(脫敏),風險等級,脫敏項目數
MSG001,2024-01-15 10:30,USER_HASH_A1B2,我是王○○...[地址]...,LOW,3
MSG002,2024-01-15 10:35,USER_HASH_A1B2,電話09XX-XXX-XXX,NONE,1
```

### 2. JSON 匯出

```json
{
  "export_metadata": {
    "exported_at": "2024-01-15T10:00:00Z",
    "redaction_level": "standard",
    "total_messages": 1000,
    "total_redacted_items": 3500
  },
  "messages": [
    {
      "id": "MSG001",
      "timestamp": "2024-01-15T10:30:00Z",
      "user_id_hash": "a1b2c3d4",
      "content_redacted": "我是王○○，住在[地址]",
      "redaction_info": {
        "count": 2,
        "types": ["name", "address"]
      }
    }
  ]
}
```

### 3. 報表格式

```markdown
# 對話分析報表（脫敏版）

## 統計摘要
- 總對話數：1,234
- 包含個資訊息：456 (37%)
- 高風險訊息：23 (1.9%)

## 脫敏類別分佈
| 類別 | 次數 | 百分比 |
|-----|------|--------|
| 姓名 | 234 | 20% |
| 電話 | 156 | 13% |
| 地址 | 98 | 8% |
| 醫療資訊 | 187 | 16% |

## 風險趨勢（不含個人識別）
[圖表：顯示風險等級隨時間變化，但不顯示個人資訊]
```

## 最佳實踐建議

### 1. 使用顏色編碼

```css
/* 根據脫敏類型使用不同顏色 */
.redacted-pii { background-color: #ffeb3b; }      /* 黃色：個人資訊 */
.redacted-medical { background-color: #ff9800; }   /* 橘色：醫療資訊 */
.redacted-contact { background-color: #03a9f4; }   /* 藍色：聯絡資訊 */
.redacted-risk { background-color: #f44336; }      /* 紅色：風險內容 */
```

### 2. 提供上下文提示

```typescript
// 滑鼠懸停顯示脫敏類型
<Tooltip title="此處包含個人身分證字號">
  <span className="redacted-pii">[身分證]</span>
</Tooltip>
```

### 3. 保留語意完整性

```python
def semantic_preserving_redaction(text):
    """保留語意的脫敏"""
    # 不要過度脫敏導致無法理解
    
    # ❌ 錯誤：過度脫敏
    # "我[動詞][名詞]在[地點]"
    
    # ✅ 正確：保留語意
    # "我最近搬家到[地址]"
    
    return preserve_context_while_redacting(text)
```

## 關鍵記憶點

1. **脫敏標記要一致** - 使用統一的標記系統
2. **保留統計價值** - 脫敏不應影響資料分析
3. **提供必要上下文** - 讓閱讀者理解對話脈絡
4. **分級存取控制** - 不同角色看到不同程度的資訊
5. **審計所有原文存取** - 任何查看原文的行為都要記錄