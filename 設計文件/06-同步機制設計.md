# 06 - 同步機制設計文件

## 快速恢復指南
如果你忘記了這個模組，記住：這是市府平台拉取資料的核心機制，採用 Pull-only 模式，支援增量同步、斷點續傳、游標分頁。關鍵是 updated_at 時間戳和 opaque cursor。

## 核心技術棧
- PostgreSQL (資料來源)
- Redis (同步狀態快取)
- APScheduler (排程器)
- asyncio (異步處理)

## 專案結構
```
sync/
├── __init__.py
├── sync_engine.py      # 同步引擎核心
├── cursor_manager.py   # 游標管理
├── incremental.py      # 增量同步邏輯
├── bookmark.py         # 書籤管理
├── scheduler.py        # 排程器
├── monitor.py          # 同步監控
└── reconciliation.py   # 對帳機制
```

## 1. 同步引擎核心

```python
# sync_engine.py
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import asyncio
from dataclasses import dataclass
import json

@dataclass
class SyncConfig:
    """同步設定"""
    consumer_id: str
    batch_size: int = 500
    max_retries: int = 3
    retry_delay: int = 5  # seconds
    timeout: int = 30  # seconds
    rate_limit: int = 5  # requests per second

@dataclass
class SyncState:
    """同步狀態"""
    consumer_id: str
    last_sync_at: Optional[datetime]
    last_conversation_cursor: Optional[str]
    last_message_cursor: Optional[str]
    total_synced: int = 0
    total_errors: int = 0
    status: str = "idle"  # idle, running, failed, completed

class SyncEngine:
    """同步引擎"""
    
    def __init__(self, db_helper, redis_client, config: SyncConfig):
        self.db = db_helper
        self.redis = redis_client
        self.config = config
        self.cursor_manager = CursorManager()
        self.bookmark_manager = BookmarkManager(db_helper)
        
        # 同步狀態
        self.state = None
        self._load_state()
    
    async def sync_conversations(
        self,
        updated_after: Optional[datetime] = None,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """同步會話資料"""
        
        try:
            self.state.status = "running"
            await self._save_state()
            
            # 取得上次同步點
            if not updated_after:
                updated_after = self.state.last_sync_at or \
                               datetime.utcnow() - timedelta(days=7)
            
            cursor = self.state.last_conversation_cursor
            total_fetched = 0
            all_items = []
            
            while True:
                # 拉取一批資料
                batch = await self._fetch_conversations_batch(
                    updated_after=updated_after,
                    cursor=cursor,
                    user_id=user_id
                )
                
                if not batch["items"]:
                    break
                
                # 處理資料
                processed = await self._process_conversations(batch["items"])
                all_items.extend(processed)
                total_fetched += len(batch["items"])
                
                # 更新游標
                cursor = batch.get("next_cursor")
                self.state.last_conversation_cursor = cursor
                
                # 儲存進度 (每批次)
                await self._save_checkpoint(
                    "conversations",
                    cursor,
                    total_fetched
                )
                
                # 檢查是否還有下一頁
                if not cursor:
                    break
                
                # Rate limiting
                await self._rate_limit()
            
            # 更新最終狀態
            self.state.status = "completed"
            self.state.last_sync_at = datetime.utcnow()
            self.state.total_synced += total_fetched
            await self._save_state()
            
            return {
                "status": "success",
                "total_fetched": total_fetched,
                "last_cursor": cursor,
                "items": all_items
            }
            
        except Exception as e:
            self.state.status = "failed"
            self.state.total_errors += 1
            await self._save_state()
            
            return {
                "status": "error",
                "error": str(e),
                "last_cursor": self.state.last_conversation_cursor
            }
    
    async def sync_messages(
        self,
        conversation_id: Optional[str] = None,
        updated_after: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """同步訊息資料"""
        
        try:
            self.state.status = "running"
            await self._save_state()
            
            if conversation_id:
                # 同步特定會話的訊息
                return await self._sync_conversation_messages(conversation_id)
            else:
                # 全域訊息增量同步
                return await self._sync_all_messages(updated_after)
            
        except Exception as e:
            self.state.status = "failed"
            self.state.total_errors += 1
            await self._save_state()
            
            return {
                "status": "error",
                "error": str(e)
            }
    
    async def _sync_conversation_messages(
        self,
        conversation_id: str
    ) -> Dict[str, Any]:
        """同步單一會話的訊息"""
        
        # 取得斷點
        after_id = await self._get_message_checkpoint(conversation_id)
        total_fetched = 0
        all_messages = []
        
        while True:
            # 拉取訊息
            batch = await self._fetch_messages_batch(
                conversation_id=conversation_id,
                after_id=after_id
            )
            
            if not batch["items"]:
                break
            
            # 處理訊息
            processed = await self._process_messages(batch["items"])
            all_messages.extend(processed)
            total_fetched += len(batch["items"])
            
            # 更新斷點
            after_id = batch.get("next_after_id")
            await self._save_message_checkpoint(conversation_id, after_id)
            
            if not after_id:
                break
            
            await self._rate_limit()
        
        return {
            "status": "success",
            "conversation_id": conversation_id,
            "total_fetched": total_fetched,
            "messages": all_messages
        }
    
    async def _sync_all_messages(
        self,
        updated_after: Optional[datetime]
    ) -> Dict[str, Any]:
        """全域訊息增量同步"""
        
        if not updated_after:
            updated_after = self.state.last_sync_at or \
                           datetime.utcnow() - timedelta(minutes=15)
        
        cursor = self.state.last_message_cursor
        total_fetched = 0
        all_messages = []
        
        while True:
            # 拉取訊息 (跨會話)
            batch = await self._fetch_global_messages_batch(
                updated_after=updated_after,
                cursor=cursor
            )
            
            if not batch["items"]:
                break
            
            # 處理訊息
            processed = await self._process_messages(batch["items"])
            all_messages.extend(processed)
            total_fetched += len(batch["items"])
            
            # 更新游標
            cursor = batch.get("next_cursor")
            self.state.last_message_cursor = cursor
            
            # 儲存進度
            await self._save_checkpoint("messages", cursor, total_fetched)
            
            if not cursor:
                break
            
            await self._rate_limit()
        
        # 更新狀態
        self.state.last_sync_at = datetime.utcnow()
        self.state.total_synced += total_fetched
        await self._save_state()
        
        return {
            "status": "success",
            "total_fetched": total_fetched,
            "messages": all_messages
        }
    
    async def _fetch_conversations_batch(
        self,
        updated_after: datetime,
        cursor: Optional[str],
        user_id: Optional[str]
    ) -> Dict:
        """拉取會話批次"""
        
        # 模擬 API 呼叫
        query = select(Conversation).where(
            Conversation.updated_at > updated_after
        )
        
        if user_id:
            query = query.where(Conversation.user_id == user_id)
        
        if cursor:
            decoded = self.cursor_manager.decode(cursor)
            query = query.where(
                or_(
                    Conversation.updated_at < decoded["timestamp"],
                    and_(
                        Conversation.updated_at == decoded["timestamp"],
                        Conversation.id > decoded["last_id"]
                    )
                )
            )
        
        query = query.order_by(
            Conversation.updated_at.desc(),
            Conversation.id
        ).limit(self.config.batch_size + 1)
        
        async with self.db.get_session() as session:
            result = await session.execute(query)
            items = result.scalars().all()
        
        # 處理分頁
        has_next = len(items) > self.config.batch_size
        if has_next:
            items = items[:self.config.batch_size]
        
        next_cursor = None
        if has_next and items:
            last_item = items[-1]
            next_cursor = self.cursor_manager.create(
                timestamp=last_item.updated_at,
                last_id=str(last_item.id)
            )
        
        return {
            "items": [self._serialize_conversation(item) for item in items],
            "next_cursor": next_cursor
        }
    
    async def _fetch_messages_batch(
        self,
        conversation_id: str,
        after_id: Optional[str]
    ) -> Dict:
        """拉取訊息批次"""
        
        query = select(ConversationMessage).where(
            ConversationMessage.conversation_id == conversation_id
        )
        
        if after_id:
            # 取得 after_id 的時間
            subquery = select(ConversationMessage.created_at).where(
                ConversationMessage.id == after_id
            )
            async with self.db.get_session() as session:
                after_time = await session.scalar(subquery)
            
            if after_time:
                query = query.where(
                    ConversationMessage.created_at > after_time
                )
        
        query = query.order_by(
            ConversationMessage.created_at
        ).limit(self.config.batch_size + 1)
        
        async with self.db.get_session() as session:
            result = await session.execute(query)
            items = result.scalars().all()
        
        # 處理分頁
        has_next = len(items) > self.config.batch_size
        if has_next:
            items = items[:self.config.batch_size]
        
        next_after_id = str(items[-1].id) if items else None
        
        return {
            "items": [self._serialize_message(item) for item in items],
            "next_after_id": next_after_id
        }
    
    async def _rate_limit(self):
        """Rate limiting"""
        await asyncio.sleep(1.0 / self.config.rate_limit)
    
    def _serialize_conversation(self, conv) -> Dict:
        """序列化會話"""
        return {
            "id": str(conv.id),
            "user_id": conv.user_id,
            "started_at": conv.started_at.isoformat(),
            "ended_at": conv.ended_at.isoformat() if conv.ended_at else None,
            "last_message_at": conv.last_message_at.isoformat() if conv.last_message_at else None,
            "updated_at": conv.updated_at.isoformat()
        }
    
    def _serialize_message(self, msg) -> Dict:
        """序列化訊息"""
        return {
            "id": str(msg.id),
            "conversation_id": str(msg.conversation_id),
            "role": msg.role,
            "content_redacted": msg.content_redacted,
            "risk": {
                "level": msg.risk_level or "NONE",
                "categories": msg.risk_categories or []
            },
            "created_at": msg.created_at.isoformat(),
            "updated_at": msg.updated_at.isoformat()
        }
    
    async def _save_checkpoint(
        self,
        data_type: str,
        cursor: str,
        count: int
    ):
        """儲存檢查點"""
        checkpoint = {
            "consumer_id": self.config.consumer_id,
            "data_type": data_type,
            "cursor": cursor,
            "count": count,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        key = f"sync:checkpoint:{self.config.consumer_id}:{data_type}"
        await self.redis.setex(
            key,
            86400,  # 24 hours
            json.dumps(checkpoint)
        )
    
    async def _load_state(self):
        """載入同步狀態"""
        # 從資料庫載入
        bookmark = await self.bookmark_manager.get_bookmark(
            self.config.consumer_id
        )
        
        if bookmark:
            self.state = SyncState(
                consumer_id=self.config.consumer_id,
                last_sync_at=bookmark.last_sync_at,
                last_conversation_cursor=bookmark.last_conversation_cursor,
                last_message_cursor=bookmark.last_message_cursor,
                total_synced=bookmark.sync_stats.get("total_synced", 0),
                total_errors=bookmark.sync_stats.get("total_errors", 0)
            )
        else:
            self.state = SyncState(consumer_id=self.config.consumer_id)
    
    async def _save_state(self):
        """儲存同步狀態"""
        await self.bookmark_manager.save_bookmark(
            consumer_id=self.config.consumer_id,
            last_conversation_cursor=self.state.last_conversation_cursor,
            last_message_cursor=self.state.last_message_cursor,
            last_sync_at=self.state.last_sync_at,
            sync_stats={
                "total_synced": self.state.total_synced,
                "total_errors": self.state.total_errors,
                "status": self.state.status
            }
        )
```

## 2. 游標管理

```python
# cursor_manager.py
import base64
import json
import secrets
from datetime import datetime
from typing import Dict, Any

class CursorManager:
    """游標管理器"""
    
    def create(
        self,
        timestamp: datetime,
        last_id: str,
        metadata: Dict = None
    ) -> str:
        """建立游標"""
        
        cursor_data = {
            "t": timestamp.isoformat(),
            "id": last_id,
            "s": secrets.token_hex(4),  # salt
            "m": metadata or {}
        }
        
        # 序列化並編碼
        json_str = json.dumps(cursor_data, separators=(",", ":"))
        encoded = base64.urlsafe_b64encode(json_str.encode()).decode()
        
        # 移除填充字元
        return encoded.rstrip("=")
    
    def decode(self, cursor: str) -> Dict[str, Any]:
        """解碼游標"""
        
        if not cursor:
            return None
        
        try:
            # 補回填充
            padding = 4 - len(cursor) % 4
            if padding != 4:
                cursor += "=" * padding
            
            # 解碼
            decoded = base64.urlsafe_b64decode(cursor)
            cursor_data = json.loads(decoded)
            
            return {
                "timestamp": datetime.fromisoformat(cursor_data["t"]),
                "last_id": cursor_data["id"],
                "metadata": cursor_data.get("m", {})
            }
        except Exception as e:
            raise ValueError(f"Invalid cursor: {e}")
    
    def validate(self, cursor: str) -> bool:
        """驗證游標有效性"""
        
        try:
            decoded = self.decode(cursor)
            
            # 檢查時間戳合理性
            timestamp = decoded["timestamp"]
            now = datetime.utcnow()
            
            # 游標不應該是未來時間
            if timestamp > now:
                return False
            
            # 游標不應該太舊 (例如超過30天)
            if (now - timestamp).days > 30:
                return False
            
            return True
            
        except:
            return False
```

## 3. 書籤管理

```python
# bookmark.py
from datetime import datetime
from typing import Optional, Dict

class BookmarkManager:
    """書籤管理器"""
    
    def __init__(self, db_helper):
        self.db = db_helper
    
    async def get_bookmark(self, consumer_id: str) -> Optional[Dict]:
        """取得書籤"""
        
        async with self.db.get_session() as session:
            result = await session.execute(
                select(SyncBookmark).where(
                    SyncBookmark.consumer_id == consumer_id
                )
            )
            bookmark = result.scalar_one_or_none()
            
            if bookmark:
                return {
                    "consumer_id": bookmark.consumer_id,
                    "last_conversation_cursor": bookmark.last_conversation_cursor,
                    "last_message_cursor": bookmark.last_message_cursor,
                    "last_sync_at": bookmark.last_sync_at,
                    "sync_stats": bookmark.sync_stats or {}
                }
            
            return None
    
    async def save_bookmark(
        self,
        consumer_id: str,
        last_conversation_cursor: Optional[str] = None,
        last_message_cursor: Optional[str] = None,
        last_sync_at: Optional[datetime] = None,
        sync_stats: Dict = None
    ):
        """儲存書籤"""
        
        async with self.db.get_session() as session:
            # 更新或插入
            bookmark = await session.get(SyncBookmark, consumer_id)
            
            if bookmark:
                # 更新現有書籤
                if last_conversation_cursor is not None:
                    bookmark.last_conversation_cursor = last_conversation_cursor
                if last_message_cursor is not None:
                    bookmark.last_message_cursor = last_message_cursor
                if last_sync_at:
                    bookmark.last_sync_at = last_sync_at
                if sync_stats:
                    bookmark.sync_stats = sync_stats
                bookmark.updated_at = datetime.utcnow()
            else:
                # 建立新書籤
                bookmark = SyncBookmark(
                    consumer_id=consumer_id,
                    last_conversation_cursor=last_conversation_cursor,
                    last_message_cursor=last_message_cursor,
                    last_sync_at=last_sync_at,
                    sync_stats=sync_stats or {}
                )
                session.add(bookmark)
            
            await session.commit()
    
    async def reset_bookmark(self, consumer_id: str):
        """重置書籤"""
        
        async with self.db.get_session() as session:
            bookmark = await session.get(SyncBookmark, consumer_id)
            
            if bookmark:
                bookmark.last_conversation_cursor = None
                bookmark.last_message_cursor = None
                bookmark.last_sync_at = None
                bookmark.sync_stats = {}
                bookmark.updated_at = datetime.utcnow()
                
                await session.commit()
```

## 4. 增量同步策略

```python
# incremental.py
from datetime import datetime, timedelta
from typing import Optional, List, Dict
import asyncio

class IncrementalSync:
    """增量同步策略"""
    
    def __init__(self, sync_engine: SyncEngine):
        self.engine = sync_engine
        self.reconciliation = ReconciliationService()
    
    async def full_sync(self, start_date: datetime = None) -> Dict:
        """全量同步"""
        
        if not start_date:
            start_date = datetime.utcnow() - timedelta(days=90)
        
        results = {
            "conversations": {"total": 0, "errors": []},
            "messages": {"total": 0, "errors": []},
            "start_time": datetime.utcnow()
        }
        
        try:
            # 1. 同步所有會話
            conv_result = await self.engine.sync_conversations(
                updated_after=start_date
            )
            results["conversations"]["total"] = conv_result["total_fetched"]
            
            # 2. 同步每個會話的訊息
            for conv in conv_result["items"]:
                try:
                    msg_result = await self.engine.sync_messages(
                        conversation_id=conv["id"]
                    )
                    results["messages"]["total"] += msg_result["total_fetched"]
                except Exception as e:
                    results["messages"]["errors"].append({
                        "conversation_id": conv["id"],
                        "error": str(e)
                    })
                
                # 避免過載
                await asyncio.sleep(0.1)
            
            results["end_time"] = datetime.utcnow()
            results["duration"] = (
                results["end_time"] - results["start_time"]
            ).total_seconds()
            
            return results
            
        except Exception as e:
            results["error"] = str(e)
            return results
    
    async def incremental_sync(
        self,
        window_minutes: int = 15
    ) -> Dict:
        """增量同步 (定期執行)"""
        
        # 計算時間窗口
        now = datetime.utcnow()
        window_start = now - timedelta(minutes=window_minutes)
        
        results = {
            "timestamp": now.isoformat(),
            "window_minutes": window_minutes,
            "conversations": 0,
            "messages": 0,
            "errors": []
        }
        
        try:
            # 1. 同步更新的會話
            conv_result = await self.engine.sync_conversations(
                updated_after=window_start
            )
            results["conversations"] = conv_result["total_fetched"]
            
            # 2. 同步全域訊息增量
            msg_result = await self.engine.sync_messages(
                updated_after=window_start
            )
            results["messages"] = msg_result["total_fetched"]
            
            # 3. 執行對帳
            if results["conversations"] > 0 or results["messages"] > 0:
                reconcile_result = await self.reconciliation.verify(
                    start_time=window_start,
                    end_time=now
                )
                results["reconciliation"] = reconcile_result
            
            return results
            
        except Exception as e:
            results["errors"].append(str(e))
            return results
    
    async def catch_up_sync(self) -> Dict:
        """追趕同步 (錯誤恢復)"""
        
        # 從上次成功同步點開始
        last_sync = self.engine.state.last_sync_at
        
        if not last_sync:
            # 沒有記錄，執行最近7天
            last_sync = datetime.utcnow() - timedelta(days=7)
        
        # 計算落後時間
        lag_hours = (datetime.utcnow() - last_sync).total_seconds() / 3600
        
        if lag_hours > 24:
            # 落後超過24小時，分批處理
            return await self._batch_catch_up(last_sync)
        else:
            # 正常增量同步
            return await self.incremental_sync()
    
    async def _batch_catch_up(
        self,
        start_time: datetime
    ) -> Dict:
        """分批追趕同步"""
        
        results = {
            "batches": [],
            "total_conversations": 0,
            "total_messages": 0
        }
        
        current = start_time
        end_time = datetime.utcnow()
        batch_hours = 6  # 每批6小時
        
        while current < end_time:
            batch_end = min(
                current + timedelta(hours=batch_hours),
                end_time
            )
            
            # 同步這個批次
            batch_result = {
                "start": current.isoformat(),
                "end": batch_end.isoformat()
            }
            
            try:
                conv_result = await self.engine.sync_conversations(
                    updated_after=current
                )
                msg_result = await self.engine.sync_messages(
                    updated_after=current
                )
                
                batch_result["conversations"] = conv_result["total_fetched"]
                batch_result["messages"] = msg_result["total_fetched"]
                
                results["total_conversations"] += batch_result["conversations"]
                results["total_messages"] += batch_result["messages"]
                
            except Exception as e:
                batch_result["error"] = str(e)
            
            results["batches"].append(batch_result)
            
            # 移到下一批
            current = batch_end
            
            # 避免過載
            await asyncio.sleep(1)
        
        return results
```

## 5. 對帳機制

```python
# reconciliation.py
from datetime import datetime
from typing import Dict, List

class ReconciliationService:
    """對帳服務"""
    
    def __init__(self, db_helper):
        self.db = db_helper
    
    async def verify(
        self,
        start_time: datetime,
        end_time: datetime
    ) -> Dict:
        """執行對帳"""
        
        results = {
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "status": "success",
            "discrepancies": []
        }
        
        # 1. 計算來源端數量
        source_counts = await self._get_source_counts(start_time, end_time)
        
        # 2. 計算目標端數量
        target_counts = await self._get_target_counts(start_time, end_time)
        
        # 3. 比對
        for data_type in ["conversations", "messages"]:
            source = source_counts.get(data_type, 0)
            target = target_counts.get(data_type, 0)
            
            if source != target:
                results["discrepancies"].append({
                    "type": data_type,
                    "source_count": source,
                    "target_count": target,
                    "difference": source - target
                })
                results["status"] = "mismatch"
        
        # 4. 檢查特定記錄
        if results["discrepancies"]:
            missing = await self._find_missing_records(start_time, end_time)
            results["missing_records"] = missing
        
        return results
    
    async def _get_source_counts(
        self,
        start_time: datetime,
        end_time: datetime
    ) -> Dict:
        """取得來源端計數"""
        
        async with self.db.get_session() as session:
            # 會話數量
            conv_count = await session.scalar(
                select(func.count(Conversation.id)).where(
                    and_(
                        Conversation.updated_at >= start_time,
                        Conversation.updated_at <= end_time
                    )
                )
            )
            
            # 訊息數量
            msg_count = await session.scalar(
                select(func.count(ConversationMessage.id)).where(
                    and_(
                        ConversationMessage.updated_at >= start_time,
                        ConversationMessage.updated_at <= end_time
                    )
                )
            )
            
            return {
                "conversations": conv_count or 0,
                "messages": msg_count or 0
            }
    
    async def _get_target_counts(
        self,
        start_time: datetime,
        end_time: datetime
    ) -> Dict:
        """取得目標端計數 (模擬)"""
        
        # 實際應該查詢目標系統
        # 這裡假設有個同步記錄表
        async with self.db.get_session() as session:
            result = await session.execute(
                select(SyncLog).where(
                    and_(
                        SyncLog.sync_time >= start_time,
                        SyncLog.sync_time <= end_time
                    )
                )
            )
            logs = result.scalars().all()
            
            counts = {
                "conversations": 0,
                "messages": 0
            }
            
            for log in logs:
                counts["conversations"] += log.conversation_count
                counts["messages"] += log.message_count
            
            return counts
    
    async def _find_missing_records(
        self,
        start_time: datetime,
        end_time: datetime
    ) -> List[Dict]:
        """找出遺失的記錄"""
        
        missing = []
        
        # 檢查會話
        async with self.db.get_session() as session:
            # 取得時間範圍內的所有會話 ID
            source_ids = await session.scalars(
                select(Conversation.id).where(
                    and_(
                        Conversation.updated_at >= start_time,
                        Conversation.updated_at <= end_time
                    )
                )
            ).all()
            
            # 檢查哪些沒有同步
            for conv_id in source_ids:
                # 檢查同步記錄
                synced = await self._check_if_synced(conv_id, "conversation")
                
                if not synced:
                    missing.append({
                        "type": "conversation",
                        "id": str(conv_id),
                        "reason": "not_synced"
                    })
        
        return missing[:100]  # 限制回傳數量
    
    async def _check_if_synced(
        self,
        record_id: str,
        record_type: str
    ) -> bool:
        """檢查記錄是否已同步"""
        
        # 實際應該查詢目標系統或同步記錄
        # 這裡簡化為檢查同步日誌
        return True  # 假設都已同步
```

## 6. 排程器

```python
# scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.cron import CronTrigger
from datetime import datetime
import logging

class SyncScheduler:
    """同步排程器"""
    
    def __init__(self, sync_engine: SyncEngine):
        self.engine = sync_engine
        self.scheduler = AsyncIOScheduler()
        self.incremental_sync = IncrementalSync(sync_engine)
        self.logger = logging.getLogger(__name__)
    
    def start(self):
        """啟動排程器"""
        
        # 增量同步 - 每5分鐘
        self.scheduler.add_job(
            self._run_incremental_sync,
            IntervalTrigger(minutes=5),
            id="incremental_sync",
            name="增量同步",
            max_instances=1,
            replace_existing=True
        )
        
        # 對帳 - 每小時
        self.scheduler.add_job(
            self._run_reconciliation,
            IntervalTrigger(hours=1),
            id="reconciliation",
            name="對帳檢查",
            max_instances=1,
            replace_existing=True
        )
        
        # 全量同步 - 每天凌晨2點
        self.scheduler.add_job(
            self._run_full_sync,
            CronTrigger(hour=2, minute=0),
            id="full_sync",
            name="全量同步",
            max_instances=1,
            replace_existing=True
        )
        
        # 清理舊資料 - 每週日凌晨3點
        self.scheduler.add_job(
            self._run_cleanup,
            CronTrigger(day_of_week=0, hour=3, minute=0),
            id="cleanup",
            name="資料清理",
            max_instances=1,
            replace_existing=True
        )
        
        self.scheduler.start()
        self.logger.info("Sync scheduler started")
    
    def stop(self):
        """停止排程器"""
        self.scheduler.shutdown()
        self.logger.info("Sync scheduler stopped")
    
    async def _run_incremental_sync(self):
        """執行增量同步"""
        
        try:
            self.logger.info("Starting incremental sync")
            
            result = await self.incremental_sync.incremental_sync(
                window_minutes=10
            )
            
            self.logger.info(
                f"Incremental sync completed: "
                f"{result['conversations']} conversations, "
                f"{result['messages']} messages"
            )
            
            # 發送監控指標
            await self._send_metrics("incremental_sync", result)
            
        except Exception as e:
            self.logger.error(f"Incremental sync failed: {e}")
            
            # 嘗試追趕同步
            try:
                await self.incremental_sync.catch_up_sync()
            except Exception as catch_up_error:
                self.logger.error(f"Catch-up sync also failed: {catch_up_error}")
    
    async def _run_reconciliation(self):
        """執行對帳"""
        
        try:
            self.logger.info("Starting reconciliation")
            
            reconciliation = ReconciliationService(self.engine.db)
            
            # 對帳最近1小時
            end_time = datetime.utcnow()
            start_time = end_time - timedelta(hours=1)
            
            result = await reconciliation.verify(start_time, end_time)
            
            if result["status"] != "success":
                self.logger.warning(
                    f"Reconciliation found discrepancies: "
                    f"{result['discrepancies']}"
                )
                
                # 觸發修復
                await self._trigger_repair(result)
            else:
                self.logger.info("Reconciliation successful")
            
        except Exception as e:
            self.logger.error(f"Reconciliation failed: {e}")
    
    async def _run_full_sync(self):
        """執行全量同步"""
        
        try:
            self.logger.info("Starting full sync")
            
            # 重置書籤
            await self.engine.bookmark_manager.reset_bookmark(
                self.engine.config.consumer_id
            )
            
            # 執行全量同步 (最近90天)
            result = await self.incremental_sync.full_sync()
            
            self.logger.info(
                f"Full sync completed: "
                f"{result['conversations']['total']} conversations, "
                f"{result['messages']['total']} messages, "
                f"duration: {result.get('duration', 0)}s"
            )
            
        except Exception as e:
            self.logger.error(f"Full sync failed: {e}")
    
    async def _run_cleanup(self):
        """清理舊資料"""
        
        try:
            self.logger.info("Starting cleanup")
            
            # 清理超過30天的同步日誌
            # 清理超過7天的檢查點
            # 壓縮舊的對帳記錄
            
            self.logger.info("Cleanup completed")
            
        except Exception as e:
            self.logger.error(f"Cleanup failed: {e}")
    
    async def _send_metrics(self, job_name: str, result: dict):
        """發送監控指標"""
        # TODO: 整合 Prometheus 或其他監控系統
        pass
    
    async def _trigger_repair(self, reconciliation_result: dict):
        """觸發修復流程"""
        # TODO: 實作自動修復邏輯
        pass
```

## 7. 監控與告警

```python
# monitor.py
from dataclasses import dataclass
from typing import List
import time

@dataclass
class SyncMetrics:
    """同步指標"""
    timestamp: float
    conversations_synced: int
    messages_synced: int
    errors: int
    duration_seconds: float
    lag_seconds: float

class SyncMonitor:
    """同步監控"""
    
    def __init__(self):
        self.metrics: List[SyncMetrics] = []
        self.alert_thresholds = {
            "lag_seconds": 3600,  # 1小時
            "error_rate": 0.1,  # 10%
            "duration_seconds": 300  # 5分鐘
        }
    
    def record_sync(
        self,
        conversations: int,
        messages: int,
        errors: int,
        duration: float,
        lag: float
    ):
        """記錄同步指標"""
        
        metric = SyncMetrics(
            timestamp=time.time(),
            conversations_synced=conversations,
            messages_synced=messages,
            errors=errors,
            duration_seconds=duration,
            lag_seconds=lag
        )
        
        self.metrics.append(metric)
        
        # 保留最近24小時
        cutoff = time.time() - 86400
        self.metrics = [m for m in self.metrics if m.timestamp > cutoff]
        
        # 檢查告警
        self._check_alerts(metric)
    
    def _check_alerts(self, metric: SyncMetrics):
        """檢查告警條件"""
        
        alerts = []
        
        # 延遲告警
        if metric.lag_seconds > self.alert_thresholds["lag_seconds"]:
            alerts.append({
                "type": "high_lag",
                "message": f"Sync lag is {metric.lag_seconds}s",
                "severity": "warning"
            })
        
        # 錯誤率告警
        if self._calculate_error_rate() > self.alert_thresholds["error_rate"]:
            alerts.append({
                "type": "high_error_rate",
                "message": "Error rate exceeds threshold",
                "severity": "critical"
            })
        
        # 執行時間告警
        if metric.duration_seconds > self.alert_thresholds["duration_seconds"]:
            alerts.append({
                "type": "slow_sync",
                "message": f"Sync took {metric.duration_seconds}s",
                "severity": "warning"
            })
        
        # 發送告警
        for alert in alerts:
            self._send_alert(alert)
    
    def _calculate_error_rate(self) -> float:
        """計算錯誤率"""
        
        if not self.metrics:
            return 0
        
        recent = self.metrics[-10:]  # 最近10次
        total = sum(m.conversations_synced + m.messages_synced for m in recent)
        errors = sum(m.errors for m in recent)
        
        if total == 0:
            return 0
        
        return errors / total
    
    def _send_alert(self, alert: dict):
        """發送告警"""
        # TODO: 整合告警系統 (Slack, Email, SMS)
        print(f"ALERT: {alert}")
    
    def get_status(self) -> dict:
        """取得同步狀態"""
        
        if not self.metrics:
            return {"status": "no_data"}
        
        latest = self.metrics[-1]
        
        return {
            "status": "healthy" if latest.errors == 0 else "degraded",
            "last_sync": latest.timestamp,
            "lag_seconds": latest.lag_seconds,
            "error_rate": self._calculate_error_rate(),
            "metrics_24h": len(self.metrics)
        }
```

## 關鍵記憶點
1. **必須**使用 cursor-based pagination，不要用 offset
2. **記得**每批次都要儲存檢查點，支援斷點續傳
3. **注意** Rate Limiting 避免過載來源系統
4. **重要**定期執行對帳確保資料一致性