# 04 - 安全機制設計文件 [暫緩實作]

## ⚠️ 注意：此功能暫緩實作
根據最新決定，安全機制暫時不實作。此文件保留作為未來參考。

## 快速恢復指南
如果你忘記了這個模組，記住：這是系統的安全防護層，包含 mTLS、OAuth2、加密、審計、WAF 等多層防護。重點是零信任架構和防禦縱深。

## 核心技術棧
- mTLS (雙向 TLS 認證)
- OAuth2 + JWT (授權)
- AES-256-GCM (資料加密)
- AWS KMS / Azure Key Vault (金鑰管理)
- Redis (Session 管理)

## 專案結構
```
security/
├── __init__.py
├── mtls.py              # mTLS 處理
├── oauth2.py            # OAuth2 實作
├── encryption.py        # 資料加密
├── audit.py            # 審計日誌
├── waf.py              # WAF 規則
├── certificates/       # 憑證管理
│   ├── ca.crt         # CA 根憑證
│   ├── server.crt     # 伺服器憑證
│   └── server.key     # 伺服器私鑰
└── config/
    ├── security.yaml   # 安全設定
    └── ip_whitelist.txt # IP 白名單
```

## 1. mTLS 雙向認證

### Nginx 設定
```nginx
# /etc/nginx/sites-available/xiongichat
server {
    listen 443 ssl http2;
    server_name api.xiongichat.kao.gov.tw;
    
    # 伺服器憑證
    ssl_certificate /etc/nginx/certs/server.crt;
    ssl_certificate_key /etc/nginx/certs/server.key;
    
    # 客戶端憑證驗證
    ssl_client_certificate /etc/nginx/certs/ca.crt;
    ssl_verify_client on;
    ssl_verify_depth 2;
    
    # TLS 設定
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers off;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # 傳遞憑證資訊給後端
    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header X-SSL-Client-Cert $ssl_client_escaped_cert;
        proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn;
        proxy_set_header X-SSL-Client-Verify $ssl_client_verify;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### Python mTLS 驗證
```python
# security/mtls.py
from fastapi import Request, HTTPException, status
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import base64
from datetime import datetime
from typing import Optional

class MTLSValidator:
    """mTLS 憑證驗證"""
    
    def __init__(self, trusted_ca_path: str):
        with open(trusted_ca_path, 'rb') as f:
            self.trusted_ca = x509.load_pem_x509_certificate(
                f.read(), 
                default_backend()
            )
    
    async def validate_client_cert(self, request: Request) -> dict:
        """驗證客戶端憑證"""
        
        # 檢查 Nginx 驗證結果
        verify_status = request.headers.get("X-SSL-Client-Verify")
        if verify_status != "SUCCESS":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Client certificate verification failed"
            )
        
        # 取得憑證
        cert_pem = request.headers.get("X-SSL-Client-Cert")
        if not cert_pem:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Client certificate not provided"
            )
        
        # URL decode
        cert_pem = cert_pem.replace(" ", "\n")
        cert_pem = f"-----BEGIN CERTIFICATE-----\n{cert_pem}\n-----END CERTIFICATE-----"
        
        try:
            # 解析憑證
            cert = x509.load_pem_x509_certificate(
                cert_pem.encode(), 
                default_backend()
            )
            
            # 檢查有效期
            now = datetime.utcnow()
            if now < cert.not_valid_before or now > cert.not_valid_after:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Client certificate expired"
                )
            
            # 提取資訊
            subject = cert.subject
            cn = self._get_cn(subject)
            
            # 檢查 CN 是否在允許清單
            allowed_clients = [
                "kao-main-platform",
                "kao-monitoring-system"
            ]
            
            if cn not in allowed_clients:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Client {cn} not authorized"
                )
            
            return {
                "client_id": cn,
                "serial_number": str(cert.serial_number),
                "not_after": cert.not_valid_after.isoformat(),
                "subject": str(subject)
            }
            
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Certificate validation error: {str(e)}"
            )
    
    def _get_cn(self, subject) -> str:
        """提取 Common Name"""
        for attribute in subject:
            if attribute.oid._name == "commonName":
                return attribute.value
        return ""

# FastAPI 中間件
@app.middleware("http")
async def mtls_middleware(request: Request, call_next):
    """mTLS 驗證中間件"""
    
    # 排除健康檢查
    if request.url.path == "/api/v1/healthz":
        return await call_next(request)
    
    # 驗證憑證
    validator = MTLSValidator("/etc/certs/ca.crt")
    client_info = await validator.validate_client_cert(request)
    
    # 儲存客戶端資訊
    request.state.client_info = client_info
    
    response = await call_next(request)
    return response
```

## 2. OAuth2 授權

```python
# security/oauth2.py
from datetime import datetime, timedelta
from typing import List, Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import secrets

# 設定
SECRET_KEY = secrets.token_urlsafe(32)  # 生產環境從環境變數讀取
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/token")

class OAuth2Provider:
    """OAuth2 提供者"""
    
    def __init__(self, db_helper):
        self.db = db_helper
    
    async def create_access_token(
        self, 
        client_id: str, 
        scopes: List[str]
    ) -> str:
        """建立 JWT token"""
        
        # Token payload
        payload = {
            "sub": client_id,
            "scopes": scopes,
            "iat": datetime.utcnow(),
            "exp": datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES),
            "jti": secrets.token_hex(16)  # Token ID for revocation
        }
        
        # 簽發 token
        token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
        
        # 記錄 token (用於撤銷)
        await self.db.save_token(
            jti=payload["jti"],
            client_id=client_id,
            expires_at=payload["exp"]
        )
        
        return token
    
    async def verify_token(self, token: str) -> dict:
        """驗證 token"""
        
        try:
            # 解碼
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            
            # 檢查是否被撤銷
            jti = payload.get("jti")
            if await self.db.is_token_revoked(jti):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token has been revoked"
                )
            
            return payload
            
        except JWTError as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Invalid token: {str(e)}"
            )
    
    async def client_credentials_flow(
        self, 
        client_id: str, 
        client_secret: str,
        requested_scopes: List[str]
    ) -> dict:
        """Client Credentials Grant"""
        
        # 驗證客戶端
        client = await self.db.get_oauth_client(client_id)
        if not client or not pwd_context.verify(client_secret, client.secret_hash):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid client credentials"
            )
        
        # 檢查 scope
        allowed_scopes = set(client.allowed_scopes)
        requested = set(requested_scopes)
        
        if not requested.issubset(allowed_scopes):
            invalid = requested - allowed_scopes
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid scopes: {invalid}"
            )
        
        # 產生 token
        access_token = await self.create_access_token(
            client_id=client_id,
            scopes=list(requested)
        )
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
            "scope": " ".join(requested)
        }

# API 端點
@app.post("/api/v1/token")
async def get_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: DatabaseHelper = Depends(get_db)
):
    """Token 端點"""
    
    provider = OAuth2Provider(db)
    
    # 解析 scope
    scopes = form_data.scopes or []
    
    # Client Credentials flow
    result = await provider.client_credentials_flow(
        client_id=form_data.username,  # client_id as username
        client_secret=form_data.password,  # client_secret as password
        requested_scopes=scopes
    )
    
    return result
```

## 3. 資料加密

```python
# security/encryption.py
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2
import os
import base64
from typing import Tuple

class DataEncryption:
    """資料加密器 (AES-256-GCM)"""
    
    def __init__(self, kms_client=None):
        self.kms = kms_client  # AWS KMS or Azure Key Vault
        self.backend = default_backend()
    
    async def encrypt(self, plaintext: str, context: dict = None) -> dict:
        """加密資料"""
        
        # 產生資料金鑰 (DEK)
        if self.kms:
            # 使用 KMS 產生資料金鑰
            dek, encrypted_dek = await self._generate_data_key_kms()
        else:
            # 本地產生 (開發環境)
            dek = os.urandom(32)  # 256 bits
            encrypted_dek = base64.b64encode(dek).decode()
        
        # 產生隨機 IV
        iv = os.urandom(12)  # 96 bits for GCM
        
        # 建立 cipher
        cipher = Cipher(
            algorithms.AES(dek),
            modes.GCM(iv),
            backend=self.backend
        )
        
        # 加密
        encryptor = cipher.encryptor()
        
        # 加入 AAD (Additional Authenticated Data)
        if context:
            aad = json.dumps(context, sort_keys=True).encode()
            encryptor.authenticate_additional_data(aad)
        
        # 加密資料
        ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize()
        
        # 清除 DEK
        dek = None
        
        return {
            "ciphertext": base64.b64encode(ciphertext).decode(),
            "iv": base64.b64encode(iv).decode(),
            "tag": base64.b64encode(encryptor.tag).decode(),
            "encrypted_dek": encrypted_dek,
            "context": context
        }
    
    async def decrypt(self, encrypted_data: dict) -> str:
        """解密資料"""
        
        # 解密資料金鑰
        if self.kms:
            dek = await self._decrypt_data_key_kms(
                encrypted_data["encrypted_dek"]
            )
        else:
            dek = base64.b64decode(encrypted_data["encrypted_dek"])
        
        # 解碼資料
        ciphertext = base64.b64decode(encrypted_data["ciphertext"])
        iv = base64.b64decode(encrypted_data["iv"])
        tag = base64.b64decode(encrypted_data["tag"])
        
        # 建立 cipher
        cipher = Cipher(
            algorithms.AES(dek),
            modes.GCM(iv, tag),
            backend=self.backend
        )
        
        # 解密
        decryptor = cipher.decryptor()
        
        # 驗證 AAD
        if encrypted_data.get("context"):
            aad = json.dumps(
                encrypted_data["context"], 
                sort_keys=True
            ).encode()
            decryptor.authenticate_additional_data(aad)
        
        # 解密資料
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        # 清除 DEK
        dek = None
        
        return plaintext.decode()
    
    async def _generate_data_key_kms(self) -> Tuple[bytes, str]:
        """使用 KMS 產生資料金鑰"""
        # AWS KMS 範例
        response = self.kms.generate_data_key(
            KeyId='arn:aws:kms:region:account:key/key-id',
            KeySpec='AES_256'
        )
        
        return (
            response['Plaintext'],  # DEK
            base64.b64encode(response['CiphertextBlob']).decode()  # 加密的 DEK
        )
    
    async def _decrypt_data_key_kms(self, encrypted_dek: str) -> bytes:
        """使用 KMS 解密資料金鑰"""
        response = self.kms.decrypt(
            CiphertextBlob=base64.b64decode(encrypted_dek)
        )
        
        return response['Plaintext']

# 使用範例
encryptor = DataEncryption()

# 加密敏感訊息
encrypted = await encryptor.encrypt(
    "使用者的敏感對話內容",
    context={"user_id": "U123", "conversation_id": "C456"}
)

# 儲存到資料庫
message.content_encrypted = encrypted["ciphertext"]
message.encryption_metadata = {
    "iv": encrypted["iv"],
    "tag": encrypted["tag"],
    "encrypted_dek": encrypted["encrypted_dek"],
    "context": encrypted["context"]
}
```

## 4. 審計日誌

```python
# security/audit.py
from datetime import datetime
from typing import Dict, Any
import json
import hashlib

class AuditLogger:
    """審計日誌記錄器"""
    
    def __init__(self, db_helper):
        self.db = db_helper
    
    async def log(
        self,
        event_type: str,
        client_id: str,
        resource: str,
        action: str,
        result: str,
        metadata: Dict[str, Any] = None,
        request: Request = None
    ):
        """記錄審計事件"""
        
        # 收集資訊
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": event_type,
            "client_id": client_id,
            "resource": resource,
            "action": action,
            "result": result,  # success, failure, denied
            "metadata": metadata or {}
        }
        
        # 加入請求資訊
        if request:
            audit_entry.update({
                "ip_address": request.client.host,
                "user_agent": request.headers.get("User-Agent"),
                "request_id": request.state.request_id,
                "trace_id": request.state.trace_id,
                "method": request.method,
                "path": request.url.path,
                "query_params": dict(request.query_params)
            })
        
        # 計算 hash (用於完整性驗證)
        audit_entry["hash"] = self._calculate_hash(audit_entry)
        
        # 非同步寫入
        await self.db.save_audit_log(audit_entry)
        
        # 高風險事件即時通知
        if event_type in ["security_breach", "unauthorized_access", "data_exposure"]:
            await self._alert_security_team(audit_entry)
    
    def _calculate_hash(self, entry: dict) -> str:
        """計算審計記錄 hash"""
        # 移除 hash 欄位本身
        entry_copy = {k: v for k, v in entry.items() if k != "hash"}
        
        # 序列化並計算 hash
        serialized = json.dumps(entry_copy, sort_keys=True)
        return hashlib.sha256(serialized.encode()).hexdigest()
    
    async def _alert_security_team(self, entry: dict):
        """通知安全團隊"""
        # TODO: 發送告警 (Email, Slack, SMS)
        pass

# 審計中間件
@app.middleware("http")
async def audit_middleware(request: Request, call_next):
    """審計中間件"""
    
    # 記錄請求開始
    start_time = datetime.utcnow()
    
    # 執行請求
    response = await call_next(request)
    
    # 計算執行時間
    duration_ms = (datetime.utcnow() - start_time).total_seconds() * 1000
    
    # 記錄審計
    if request.state.get("client_info"):
        logger = AuditLogger(request.app.state.db)
        
        await logger.log(
            event_type="api_access",
            client_id=request.state.client_info.get("client_id"),
            resource=request.url.path,
            action=request.method,
            result="success" if response.status_code < 400 else "failure",
            metadata={
                "status_code": response.status_code,
                "duration_ms": duration_ms
            },
            request=request
        )
    
    return response
```

## 5. WAF 規則

```python
# security/waf.py
import re
from typing import List, Dict
from fastapi import Request, HTTPException

class WebApplicationFirewall:
    """WAF 規則引擎"""
    
    # SQL Injection patterns
    SQL_PATTERNS = [
        r"(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER)\b)",
        r"(--|\||;|\/\*|\*\/)",
        r"(\bOR\b\s*\d+\s*=\s*\d+)",
        r"(\bAND\b\s*\d+\s*=\s*\d+)"
    ]
    
    # XSS patterns
    XSS_PATTERNS = [
        r"(<script[^>]*>.*?</script>)",
        r"(javascript:)",
        r"(on\w+\s*=)",
        r"(<iframe[^>]*>)"
    ]
    
    # Path Traversal patterns
    PATH_PATTERNS = [
        r"(\.\./)",
        r"(\.\.\\)",
        r"(%2e%2e/)",
        r"(%252e%252e/)"
    ]
    
    def __init__(self):
        self.compile_patterns()
    
    def compile_patterns(self):
        """編譯正則表達式"""
        self.sql_regex = [re.compile(p, re.IGNORECASE) for p in self.SQL_PATTERNS]
        self.xss_regex = [re.compile(p, re.IGNORECASE) for p in self.XSS_PATTERNS]
        self.path_regex = [re.compile(p, re.IGNORECASE) for p in self.PATH_PATTERNS]
    
    async def inspect_request(self, request: Request) -> Dict:
        """檢查請求"""
        
        threats = []
        
        # 檢查 URL
        url_str = str(request.url)
        threats.extend(self._check_patterns(url_str, "url"))
        
        # 檢查 Headers
        for name, value in request.headers.items():
            if name.lower() not in ["authorization", "cookie"]:  # 排除敏感標頭
                threats.extend(self._check_patterns(value, f"header:{name}"))
        
        # 檢查 Query Parameters
        for name, value in request.query_params.items():
            threats.extend(self._check_patterns(value, f"query:{name}"))
        
        # 檢查 Body (如果有)
        if request.method in ["POST", "PUT", "PATCH"]:
            try:
                body = await request.body()
                if body:
                    body_str = body.decode('utf-8', errors='ignore')
                    threats.extend(self._check_patterns(body_str, "body"))
            except:
                pass
        
        # 如果發現威脅
        if threats:
            # 記錄安全事件
            await self._log_security_event(request, threats)
            
            # 決定是否阻擋
            if self._should_block(threats):
                raise HTTPException(
                    status_code=403,
                    detail="Request blocked by WAF"
                )
        
        return {
            "threats": threats,
            "blocked": False
        }
    
    def _check_patterns(self, text: str, location: str) -> List[Dict]:
        """檢查威脅模式"""
        threats = []
        
        # SQL Injection
        for regex in self.sql_regex:
            if regex.search(text):
                threats.append({
                    "type": "sql_injection",
                    "location": location,
                    "severity": "high"
                })
                break
        
        # XSS
        for regex in self.xss_regex:
            if regex.search(text):
                threats.append({
                    "type": "xss",
                    "location": location,
                    "severity": "high"
                })
                break
        
        # Path Traversal
        for regex in self.path_regex:
            if regex.search(text):
                threats.append({
                    "type": "path_traversal",
                    "location": location,
                    "severity": "medium"
                })
                break
        
        return threats
    
    def _should_block(self, threats: List[Dict]) -> bool:
        """決定是否阻擋請求"""
        # 有高嚴重性威脅就阻擋
        return any(t["severity"] == "high" for t in threats)
    
    async def _log_security_event(self, request: Request, threats: List[Dict]):
        """記錄安全事件"""
        # TODO: 寫入安全事件日誌
        pass

# WAF 中間件
@app.middleware("http")
async def waf_middleware(request: Request, call_next):
    """WAF 中間件"""
    
    waf = WebApplicationFirewall()
    await waf.inspect_request(request)
    
    response = await call_next(request)
    return response
```

## 6. IP 白名單

```python
# security/ip_whitelist.py
from ipaddress import ip_address, ip_network
from typing import List

class IPWhitelist:
    """IP 白名單管理"""
    
    def __init__(self, whitelist_file: str):
        self.allowed_ips = self._load_whitelist(whitelist_file)
    
    def _load_whitelist(self, file_path: str) -> List:
        """載入白名單"""
        allowed = []
        
        with open(file_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    try:
                        # 支援單一 IP 或 CIDR
                        if '/' in line:
                            allowed.append(ip_network(line))
                        else:
                            allowed.append(ip_address(line))
                    except:
                        pass
        
        return allowed
    
    def is_allowed(self, ip: str) -> bool:
        """檢查 IP 是否允許"""
        try:
            addr = ip_address(ip)
            
            for allowed in self.allowed_ips:
                if isinstance(allowed, ip_address):
                    if addr == allowed:
                        return True
                else:  # ip_network
                    if addr in allowed:
                        return True
            
            return False
        except:
            return False

# IP 檢查中間件
@app.middleware("http")
async def ip_whitelist_middleware(request: Request, call_next):
    """IP 白名單中間件"""
    
    # 取得真實 IP (考慮代理)
    real_ip = request.headers.get("X-Real-IP", request.client.host)
    
    # 檢查白名單
    whitelist = IPWhitelist("/etc/xiongichat/ip_whitelist.txt")
    
    if not whitelist.is_allowed(real_ip):
        raise HTTPException(
            status_code=403,
            detail=f"IP {real_ip} not allowed"
        )
    
    response = await call_next(request)
    return response
```

## 7. Session 管理

```python
# security/session.py
import secrets
from datetime import datetime, timedelta

class SessionManager:
    """Session 管理器"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.session_ttl = 3600  # 1 小時
    
    async def create_session(self, client_id: str, metadata: dict) -> str:
        """建立 session"""
        
        # 產生 session ID
        session_id = secrets.token_urlsafe(32)
        
        # Session 資料
        session_data = {
            "session_id": session_id,
            "client_id": client_id,
            "created_at": datetime.utcnow().isoformat(),
            "last_activity": datetime.utcnow().isoformat(),
            "metadata": metadata
        }
        
        # 儲存到 Redis
        key = f"session:{session_id}"
        await self.redis.setex(
            key,
            self.session_ttl,
            json.dumps(session_data)
        )
        
        return session_id
    
    async def validate_session(self, session_id: str) -> dict:
        """驗證 session"""
        
        key = f"session:{session_id}"
        data = await self.redis.get(key)
        
        if not data:
            raise HTTPException(
                status_code=401,
                detail="Invalid or expired session"
            )
        
        session = json.loads(data)
        
        # 更新活動時間
        session["last_activity"] = datetime.utcnow().isoformat()
        await self.redis.setex(
            key,
            self.session_ttl,
            json.dumps(session)
        )
        
        return session
    
    async def destroy_session(self, session_id: str):
        """銷毀 session"""
        key = f"session:{session_id}"
        await self.redis.delete(key)
```

## 安全檢查清單

- [ ] mTLS 憑證定期輪替 (90天)
- [ ] OAuth2 secret 使用強密碼
- [ ] 資料加密金鑰使用 KMS 管理
- [ ] 審計日誌定期備份
- [ ] WAF 規則定期更新
- [ ] IP 白名單定期審查
- [ ] Session 設定適當 TTL
- [ ] 所有密碼使用 bcrypt 或 argon2
- [ ] HTTPS 強制使用 TLS 1.2+
- [ ] 實作 CSRF 保護
- [ ] 設定 CORS 政策
- [ ] 實作 Rate Limiting
- [ ] 定期安全掃描
- [ ] 滲透測試

## 關鍵記憶點
1. **絕對不要**在程式碼中硬編碼密鑰
2. **必須**對所有敏感資料加密
3. **記得**記錄所有安全相關事件
4. **重要**定期輪替憑證和密鑰