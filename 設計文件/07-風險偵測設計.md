# 07 - 風險偵測設計文件

## 快速恢復指南
如果你忘記了這個模組，記住：這是系統的安全防護網，負責即時偵測自殺、暴力、用藥、犯罪等風險訊號。採用規則+ML雙層檢測，支援多語言，並觸發相應的危機干預機制。

## 核心技術棧
- Transformers (BERT/RoBERTa 分類器)
- scikit-learn (規則引擎)
- Redis (風險快取)
- PostgreSQL (風險事件存儲)

## 專案結構
```
risk_detection/
├── __init__.py
├── detector.py         # 主偵測引擎
├── rules/              # 規則定義
│   ├── keywords.yaml   # 關鍵字規則
│   ├── patterns.yaml   # 模式規則
│   └── phrases.yaml    # 片語規則
├── models/             # ML 模型
│   ├── risk_classifier.py
│   ├── bert_zh/       # 中文 BERT
│   └── roberta_en/    # 英文 RoBERTa
├── handlers/           # 風險處理器
│   ├── crisis.py      # 危機處理
│   ├── notification.py # 通知機制
│   └── intervention.py # 干預策略
└── analytics/          # 風險分析
    ├── trends.py      # 趨勢分析
    └── reports.py     # 報表生成
```

## 1. 風險等級定義

```python
# risk_levels.py
from enum import Enum
from dataclasses import dataclass
from typing import List, Optional

class RiskLevel(Enum):
    """風險等級"""
    NONE = "NONE"           # 無風險
    LOW = "LOW"             # 低風險 - 需要關注
    MEDIUM = "MEDIUM"       # 中風險 - 需要介入
    HIGH = "HIGH"           # 高風險 - 立即介入
    IMMINENT = "IMMINENT"   # 危急 - 緊急處理

class RiskCategory(Enum):
    """風險類別"""
    SELF_HARM = "self_harm"           # 自我傷害
    SUICIDE = "suicide"               # 自殺意念
    VIOLENCE = "violence"             # 暴力傾向
    DRUG_USE = "drug_use"            # 藥物使用
    DRUG_DEAL = "drug_deal"          # 藥物交易
    CRIME = "crime"                  # 犯罪意圖
    RELAPSE = "relapse"              # 復發風險
    MENTAL_HEALTH = "mental_health"  # 心理健康
    SOCIAL_RISK = "social_risk"      # 社會風險

@dataclass
class RiskIndicator:
    """風險指標"""
    category: RiskCategory
    level: RiskLevel
    confidence: float  # 0.0 - 1.0
    evidence: List[str]
    recommended_action: Optional[str]
    
@dataclass
class RiskAssessment:
    """風險評估結果"""
    overall_level: RiskLevel
    categories: List[RiskCategory]
    indicators: List[RiskIndicator]
    timestamp: datetime
    context: dict
    intervention_required: bool
    alert_sent: bool = False
```

## 2. 關鍵字規則引擎

```yaml
# rules/keywords.yaml
risk_keywords:
  suicide:
    high_risk:
      zh-TW:
        - 想死
        - 不想活
        - 結束生命
        - 自殺
        - 跳樓
        - 上吊
        - 割腕
        - 吃安眠藥
        - 遺書
      en:
        - kill myself
        - end my life
        - suicide
        - want to die
        - no reason to live
    
    medium_risk:
      zh-TW:
        - 活著好累
        - 沒有意義
        - 消失
        - 解脫
        - 離開這世界
      en:
        - tired of living
        - meaningless
        - disappear
        - give up
    
  violence:
    high_risk:
      zh-TW:
        - 殺死
        - 報復
        - 弄死他
        - 教訓
        - 打爆
      en:
        - kill him
        - revenge
        - beat up
        - hurt them
    
  drug_use:
    high_risk:
      zh-TW:
        - 注射
        - 打藥
        - 吸毒
        - 嗑藥
        - 拉K
        - 用安
      en:
        - shoot up
        - using drugs
        - get high
        - meth
        - heroin
    
    medium_risk:
      zh-TW:
        - 想用
        - 戒不掉
        - 藥頭
        - 貨
        - 純度
      en:
        - craving
        - can't quit
        - dealer
        - stuff
        
  relapse:
    indicators:
      zh-TW:
        - 好想用
        - 受不了了
        - 快撐不住
        - 又開始想
        - 心癢
      en:
        - craving badly
        - can't resist
        - falling apart
        - tempted
```

```python
# detector.py
import re
import yaml
from typing import Dict, List, Tuple
from dataclasses import dataclass

class KeywordDetector:
    """關鍵字偵測器"""
    
    def __init__(self, rules_path: str = "rules/keywords.yaml"):
        with open(rules_path, 'r', encoding='utf-8') as f:
            self.rules = yaml.safe_load(f)
        
        # 編譯正則表達式
        self._compile_patterns()
    
    def _compile_patterns(self):
        """編譯關鍵字為正則表達式"""
        self.compiled_rules = {}
        
        for category, levels in self.rules['risk_keywords'].items():
            self.compiled_rules[category] = {}
            
            for level, languages in levels.items():
                self.compiled_rules[category][level] = {}
                
                for lang, keywords in languages.items():
                    # 建立正則表達式 (忽略大小寫)
                    pattern = '|'.join(
                        re.escape(keyword) for keyword in keywords
                    )
                    self.compiled_rules[category][level][lang] = re.compile(
                        pattern,
                        re.IGNORECASE
                    )
    
    def detect(
        self,
        text: str,
        lang: str = "zh-TW"
    ) -> List[RiskIndicator]:
        """偵測風險關鍵字"""
        
        indicators = []
        
        for category, levels in self.compiled_rules.items():
            for level_name, languages in levels.items():
                if lang in languages:
                    pattern = languages[lang]
                    matches = pattern.findall(text)
                    
                    if matches:
                        # 計算風險等級
                        if level_name == "high_risk":
                            level = RiskLevel.HIGH
                            confidence = 0.9
                        elif level_name == "medium_risk":
                            level = RiskLevel.MEDIUM
                            confidence = 0.7
                        else:
                            level = RiskLevel.LOW
                            confidence = 0.5
                        
                        indicators.append(RiskIndicator(
                            category=RiskCategory(category),
                            level=level,
                            confidence=confidence,
                            evidence=[f"keyword:{m}" for m in matches[:3]],
                            recommended_action=self._get_action(category, level)
                        ))
        
        return indicators
    
    def _get_action(self, category: str, level: RiskLevel) -> str:
        """取得建議行動"""
        
        actions = {
            ("suicide", RiskLevel.HIGH): "立即啟動危機干預協議，提供24小時熱線",
            ("suicide", RiskLevel.MEDIUM): "表達關心，評估風險，提供支持資源",
            ("violence", RiskLevel.HIGH): "評估威脅真實性，必要時通知相關單位",
            ("drug_use", RiskLevel.HIGH): "提供戒治資源，安排緊急諮詢",
            ("relapse", RiskLevel.MEDIUM): "加強支持，安排諮詢師介入"
        }
        
        return actions.get((category, level), "持續觀察，提供支持")
```

## 3. ML 風險分類器

```python
# models/risk_classifier.py
from transformers import (
    AutoTokenizer, 
    AutoModelForSequenceClassification,
    pipeline
)
import torch
import numpy as np
from typing import Dict, List

class MLRiskClassifier:
    """機器學習風險分類器"""
    
    def __init__(self, model_path: str = None):
        # 載入預訓練模型
        if model_path:
            self.model = AutoModelForSequenceClassification.from_pretrained(
                model_path
            )
            self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        else:
            # 使用預設模型
            self._load_default_model()
        
        # 建立 pipeline
        self.classifier = pipeline(
            "text-classification",
            model=self.model,
            tokenizer=self.tokenizer,
            device=0 if torch.cuda.is_available() else -1
        )
        
        # 標籤映射
        self.label_map = {
            "SAFE": RiskLevel.NONE,
            "LOW_RISK": RiskLevel.LOW,
            "MEDIUM_RISK": RiskLevel.MEDIUM,
            "HIGH_RISK": RiskLevel.HIGH,
            "CRISIS": RiskLevel.IMMINENT
        }
    
    def _load_default_model(self):
        """載入預設模型"""
        # 使用微調過的 BERT 模型
        model_name = "bert-base-chinese"  # 或自訂模型
        
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModelForSequenceClassification.from_pretrained(
            model_name,
            num_labels=5  # 5個風險等級
        )
        
        # 如果有本地權重檔
        try:
            checkpoint = torch.load("models/risk_bert_checkpoint.pt")
            self.model.load_state_dict(checkpoint['model_state_dict'])
        except:
            pass
    
    def predict(self, text: str) -> Dict:
        """預測風險等級"""
        
        # 執行分類
        results = self.classifier(text, top_k=None)
        
        # 轉換結果
        predictions = {}
        for result in results:
            label = result['label']
            score = result['score']
            
            risk_level = self.label_map.get(label, RiskLevel.NONE)
            predictions[risk_level] = score
        
        # 取得最高風險
        max_risk = max(predictions.items(), key=lambda x: x[1])
        
        return {
            "level": max_risk[0],
            "confidence": max_risk[1],
            "all_scores": predictions
        }
    
    def predict_batch(self, texts: List[str]) -> List[Dict]:
        """批次預測"""
        
        results = []
        
        # 批次處理提升效率
        batch_size = 32
        for i in range(0, len(texts), batch_size):
            batch = texts[i:i+batch_size]
            batch_results = self.classifier(batch, top_k=None)
            
            for j, text_results in enumerate(batch_results):
                predictions = {}
                for result in text_results:
                    label = result['label']
                    score = result['score']
                    risk_level = self.label_map.get(label, RiskLevel.NONE)
                    predictions[risk_level] = score
                
                max_risk = max(predictions.items(), key=lambda x: x[1])
                results.append({
                    "text": batch[j],
                    "level": max_risk[0],
                    "confidence": max_risk[1],
                    "all_scores": predictions
                })
        
        return results
```

## 4. 上下文感知偵測

```python
# context_detector.py
from typing import List, Dict, Optional
from collections import deque

class ContextAwareDetector:
    """上下文感知風險偵測器"""
    
    def __init__(self, window_size: int = 5):
        self.window_size = window_size
        self.conversation_history = {}  # {conversation_id: deque}
        self.user_profiles = {}  # {user_id: profile}
    
    def analyze_with_context(
        self,
        text: str,
        conversation_id: str,
        user_id: str,
        user_profile: Dict
    ) -> RiskAssessment:
        """結合上下文分析風險"""
        
        # 更新對話歷史
        if conversation_id not in self.conversation_history:
            self.conversation_history[conversation_id] = deque(
                maxlen=self.window_size
            )
        
        history = self.conversation_history[conversation_id]
        
        # 分析當前訊息
        current_indicators = self._analyze_current(text)
        
        # 分析歷史趨勢
        trend_indicators = self._analyze_trend(history, text)
        
        # 分析使用者風險因子
        profile_indicators = self._analyze_profile(user_profile)
        
        # 綜合評估
        assessment = self._combine_assessments(
            current_indicators,
            trend_indicators,
            profile_indicators
        )
        
        # 更新歷史
        history.append({
            "text": text,
            "assessment": assessment,
            "timestamp": datetime.utcnow()
        })
        
        return assessment
    
    def _analyze_current(self, text: str) -> List[RiskIndicator]:
        """分析當前訊息"""
        
        indicators = []
        
        # 情緒分析
        emotion = self._detect_emotion(text)
        if emotion in ["despair", "anger", "hopeless"]:
            indicators.append(RiskIndicator(
                category=RiskCategory.MENTAL_HEALTH,
                level=RiskLevel.MEDIUM,
                confidence=0.7,
                evidence=[f"emotion:{emotion}"],
                recommended_action="提供情緒支持"
            ))
        
        # 時間緊迫性
        urgency = self._detect_urgency(text)
        if urgency > 0.7:
            # 提升所有風險等級
            for indicator in indicators:
                if indicator.level == RiskLevel.MEDIUM:
                    indicator.level = RiskLevel.HIGH
                elif indicator.level == RiskLevel.LOW:
                    indicator.level = RiskLevel.MEDIUM
        
        return indicators
    
    def _analyze_trend(
        self,
        history: deque,
        current_text: str
    ) -> List[RiskIndicator]:
        """分析歷史趨勢"""
        
        if len(history) < 2:
            return []
        
        indicators = []
        
        # 計算風險升級趨勢
        risk_scores = []
        for entry in history:
            assessment = entry.get("assessment")
            if assessment:
                # 將風險等級轉換為數值
                level_scores = {
                    RiskLevel.NONE: 0,
                    RiskLevel.LOW: 1,
                    RiskLevel.MEDIUM: 2,
                    RiskLevel.HIGH: 3,
                    RiskLevel.IMMINENT: 4
                }
                score = level_scores.get(assessment.overall_level, 0)
                risk_scores.append(score)
        
        # 檢查是否有上升趨勢
        if len(risk_scores) >= 3:
            recent_trend = risk_scores[-3:]
            if all(recent_trend[i] <= recent_trend[i+1] 
                   for i in range(len(recent_trend)-1)):
                # 風險持續上升
                indicators.append(RiskIndicator(
                    category=RiskCategory.MENTAL_HEALTH,
                    level=RiskLevel.HIGH,
                    confidence=0.8,
                    evidence=["escalating_risk_pattern"],
                    recommended_action="立即介入，風險升級中"
                ))
        
        # 檢查重複出現的風險主題
        themes = self._extract_themes(history)
        if "suicide" in themes and themes["suicide"] >= 3:
            indicators.append(RiskIndicator(
                category=RiskCategory.SUICIDE,
                level=RiskLevel.HIGH,
                confidence=0.85,
                evidence=["persistent_suicide_ideation"],
                recommended_action="需要專業心理評估"
            ))
        
        return indicators
    
    def _analyze_profile(self, profile: Dict) -> List[RiskIndicator]:
        """分析使用者風險因子"""
        
        indicators = []
        
        # 檢查復發高風險期
        if profile.get("stage") == "treatment":
            days_in_treatment = profile.get("days_in_treatment", 0)
            
            # 前30天和90天是高風險期
            if days_in_treatment <= 30:
                indicators.append(RiskIndicator(
                    category=RiskCategory.RELAPSE,
                    level=RiskLevel.MEDIUM,
                    confidence=0.6,
                    evidence=["early_treatment_stage"],
                    recommended_action="加強初期支持"
                ))
            elif 80 <= days_in_treatment <= 100:
                indicators.append(RiskIndicator(
                    category=RiskCategory.RELAPSE,
                    level=RiskLevel.MEDIUM,
                    confidence=0.65,
                    evidence=["90_day_milestone"],
                    recommended_action="關注90天關卡"
                ))
        
        # 檢查歷史風險事件
        risk_history = profile.get("risk_history", [])
        if risk_history:
            recent_events = [
                e for e in risk_history 
                if (datetime.utcnow() - e["timestamp"]).days <= 30
            ]
            
            if len(recent_events) >= 2:
                indicators.append(RiskIndicator(
                    category=RiskCategory.MENTAL_HEALTH,
                    level=RiskLevel.MEDIUM,
                    confidence=0.7,
                    evidence=["multiple_recent_risk_events"],
                    recommended_action="需要密切關注"
                ))
        
        return indicators
    
    def _detect_emotion(self, text: str) -> str:
        """偵測情緒"""
        # 簡化版情緒偵測
        emotions = {
            "despair": ["絕望", "沒希望", "hopeless", "no hope"],
            "anger": ["生氣", "憤怒", "恨", "angry", "hate"],
            "hopeless": ["無助", "沒用", "helpless", "useless"],
            "anxious": ["焦慮", "緊張", "害怕", "anxious", "scared"]
        }
        
        for emotion, keywords in emotions.items():
            if any(keyword in text.lower() for keyword in keywords):
                return emotion
        
        return "neutral"
    
    def _detect_urgency(self, text: str) -> float:
        """偵測緊迫性"""
        
        urgent_phrases = [
            "現在", "馬上", "立刻", "今天", "等不及",
            "now", "immediately", "today", "can't wait"
        ]
        
        urgent_count = sum(
            1 for phrase in urgent_phrases 
            if phrase in text.lower()
        )
        
        return min(urgent_count * 0.3, 1.0)
    
    def _extract_themes(self, history: deque) -> Dict[str, int]:
        """提取主題"""
        
        themes = {}
        
        for entry in history:
            assessment = entry.get("assessment")
            if assessment:
                for category in assessment.categories:
                    theme = category.value
                    themes[theme] = themes.get(theme, 0) + 1
        
        return themes
    
    def _combine_assessments(
        self,
        current: List[RiskIndicator],
        trend: List[RiskIndicator],
        profile: List[RiskIndicator]
    ) -> RiskAssessment:
        """綜合評估"""
        
        all_indicators = current + trend + profile
        
        if not all_indicators:
            return RiskAssessment(
                overall_level=RiskLevel.NONE,
                categories=[],
                indicators=[],
                timestamp=datetime.utcnow(),
                context={},
                intervention_required=False
            )
        
        # 取最高風險等級
        max_level = max(
            indicator.level for indicator in all_indicators
        )
        
        # 收集所有類別
        categories = list(set(
            indicator.category for indicator in all_indicators
        ))
        
        # 判斷是否需要介入
        intervention_required = (
            max_level in [RiskLevel.HIGH, RiskLevel.IMMINENT] or
            len([i for i in all_indicators if i.level >= RiskLevel.MEDIUM]) >= 3
        )
        
        return RiskAssessment(
            overall_level=max_level,
            categories=categories,
            indicators=all_indicators,
            timestamp=datetime.utcnow(),
            context={
                "has_trend": len(trend) > 0,
                "has_profile_risk": len(profile) > 0
            },
            intervention_required=intervention_required
        )
```

## 5. 危機處理機制

```python
# handlers/crisis.py
from typing import Dict, List
import asyncio
from datetime import datetime

class CrisisHandler:
    """危機處理器"""
    
    def __init__(self, notification_service, db_helper):
        self.notification = notification_service
        self.db = db_helper
        
        # 危機處理協議
        self.protocols = {
            RiskLevel.IMMINENT: self._handle_imminent_crisis,
            RiskLevel.HIGH: self._handle_high_risk,
            RiskLevel.MEDIUM: self._handle_medium_risk
        }
    
    async def handle(
        self,
        assessment: RiskAssessment,
        user_id: str,
        conversation_id: str
    ) -> Dict:
        """處理風險事件"""
        
        # 記錄風險事件
        event_id = await self._log_risk_event(
            assessment,
            user_id,
            conversation_id
        )
        
        # 根據風險等級執行協議
        protocol = self.protocols.get(assessment.overall_level)
        
        if protocol:
            response = await protocol(
                assessment,
                user_id,
                conversation_id,
                event_id
            )
        else:
            response = {"action": "monitor", "notifications": []}
        
        # 更新事件狀態
        await self._update_event_status(event_id, response)
        
        return response
    
    async def _handle_imminent_crisis(
        self,
        assessment: RiskAssessment,
        user_id: str,
        conversation_id: str,
        event_id: str
    ) -> Dict:
        """處理危急情況"""
        
        actions = []
        
        # 1. 立即通知危機團隊
        await self.notification.alert_crisis_team({
            "event_id": event_id,
            "user_id": user_id,
            "level": "IMMINENT",
            "categories": [c.value for c in assessment.categories],
            "timestamp": assessment.timestamp
        })
        actions.append("crisis_team_alerted")
        
        # 2. 發送緊急資源給使用者
        crisis_resources = self._get_crisis_resources(assessment.categories)
        actions.append("resources_sent")
        
        # 3. 啟動24小時監控
        await self._activate_monitoring(user_id, duration_hours=24)
        actions.append("24h_monitoring_activated")
        
        # 4. 通知個案管理師
        case_manager = await self._get_case_manager(user_id)
        if case_manager:
            await self.notification.notify_case_manager(
                case_manager,
                event_id,
                assessment
            )
            actions.append("case_manager_notified")
        
        return {
            "action": "crisis_intervention",
            "actions_taken": actions,
            "resources": crisis_resources,
            "follow_up_required": True,
            "monitoring_duration": 24
        }
    
    async def _handle_high_risk(
        self,
        assessment: RiskAssessment,
        user_id: str,
        conversation_id: str,
        event_id: str
    ) -> Dict:
        """處理高風險情況"""
        
        actions = []
        
        # 1. 通知值班諮詢師
        on_duty = await self._get_on_duty_counselor()
        if on_duty:
            await self.notification.notify_counselor(
                on_duty,
                event_id,
                assessment
            )
            actions.append("counselor_notified")
        
        # 2. 排程後續追蹤
        follow_up = await self._schedule_follow_up(
            user_id,
            hours_later=4
        )
        actions.append(f"follow_up_scheduled:{follow_up}")
        
        # 3. 加強支持訊息
        support_message = self._generate_support_message(assessment)
        actions.append("support_message_generated")
        
        return {
            "action": "high_risk_intervention",
            "actions_taken": actions,
            "support_message": support_message,
            "follow_up_required": True,
            "escalate_if_persist": True
        }
    
    async def _handle_medium_risk(
        self,
        assessment: RiskAssessment,
        user_id: str,
        conversation_id: str,
        event_id: str
    ) -> Dict:
        """處理中度風險"""
        
        actions = []
        
        # 1. 記錄並追蹤
        await self._add_to_watchlist(user_id, assessment)
        actions.append("added_to_watchlist")
        
        # 2. 提供支持資源
        resources = self._get_support_resources(assessment.categories)
        actions.append("resources_provided")
        
        return {
            "action": "monitor_and_support",
            "actions_taken": actions,
            "resources": resources,
            "follow_up_required": False,
            "monitoring": "passive"
        }
    
    async def _log_risk_event(
        self,
        assessment: RiskAssessment,
        user_id: str,
        conversation_id: str
    ) -> str:
        """記錄風險事件"""
        
        event = {
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "conversation_id": conversation_id,
            "timestamp": assessment.timestamp,
            "risk_level": assessment.overall_level.value,
            "categories": [c.value for c in assessment.categories],
            "indicators": [
                {
                    "category": i.category.value,
                    "level": i.level.value,
                    "confidence": i.confidence,
                    "evidence": i.evidence
                }
                for i in assessment.indicators
            ],
            "intervention_required": assessment.intervention_required,
            "status": "new"
        }
        
        # 儲存到資料庫
        async with self.db.get_session() as session:
            session.add(RiskEvent(**event))
            await session.commit()
        
        # 快取到 Redis for 快速查詢
        await self._cache_event(event)
        
        return event["id"]
    
    def _get_crisis_resources(
        self,
        categories: List[RiskCategory]
    ) -> Dict:
        """取得危機資源"""
        
        resources = {
            "hotlines": [
                {"name": "生命線", "number": "1995", "available": "24/7"},
                {"name": "張老師", "number": "1980", "available": "24/7"},
                {"name": "安心專線", "number": "1925", "available": "24/7"}
            ],
            "emergency": {
                "number": "119",
                "description": "緊急醫療救助"
            }
        }
        
        # 根據風險類別加入特定資源
        if RiskCategory.DRUG_USE in categories:
            resources["specialized"] = [
                {
                    "name": "毒防中心",
                    "number": "0800-770-885",
                    "description": "藥物濫用諮詢"
                }
            ]
        
        if RiskCategory.MENTAL_HEALTH in categories:
            resources["mental_health"] = [
                {
                    "name": "心理衛生中心",
                    "description": "專業心理諮商",
                    "booking": "線上預約"
                }
            ]
        
        return resources
    
    def _generate_support_message(
        self,
        assessment: RiskAssessment
    ) -> str:
        """生成支持訊息"""
        
        if RiskCategory.SUICIDE in assessment.categories:
            return """
我聽到你現在很痛苦，這一定很不容易。
請記得你並不孤單，我們都在這裡支持你。

如果你需要立即與人談談：
- 生命線：1995 (24小時)
- 張老師：1980 (24小時)

你的生命很重要，讓我們一起度過這個困難時期。
            """
        
        elif RiskCategory.RELAPSE in assessment.categories:
            return """
復原的路不容易，有想要使用的念頭是正常的。
這不代表失敗，而是復原過程的一部分。

試試這些方法：
- 深呼吸，讓念頭過去
- 打電話給支持你的人
- 做一些轉移注意力的活動

你已經走了這麼遠，我相信你可以繼續堅持。
            """
        
        else:
            return """
我注意到你可能正在經歷一些困難。
請記得，尋求幫助是勇敢的表現。

我們的團隊隨時準備支持你。
如果你想談談，我們都在這裡傾聽。
            """
```

## 6. 通知與告警

```python
# handlers/notification.py
from typing import Dict, List
import aiohttp
import smtplib
from email.mime.text import MIMEText

class NotificationService:
    """通知服務"""
    
    def __init__(self, config: dict):
        self.config = config
        self.channels = {
            "sms": self._send_sms,
            "email": self._send_email,
            "line": self._send_line,
            "slack": self._send_slack,
            "webhook": self._send_webhook
        }
    
    async def alert_crisis_team(self, event: Dict):
        """通知危機團隊"""
        
        message = self._format_crisis_alert(event)
        
        # 多通道通知確保送達
        tasks = []
        
        # SMS 給值班人員
        on_duty = await self._get_on_duty_staff()
        for staff in on_duty:
            tasks.append(
                self._send_sms(staff["phone"], message["sms"])
            )
        
        # Slack 通知團隊頻道
        tasks.append(
            self._send_slack("#crisis-response", message["detailed"])
        )
        
        # Email 給主管
        supervisors = await self._get_supervisors()
        for supervisor in supervisors:
            tasks.append(
                self._send_email(
                    supervisor["email"],
                    "🚨 危機事件通知",
                    message["detailed"]
                )
            )
        
        # 執行所有通知
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 記錄通知結果
        await self._log_notifications(event["event_id"], results)
        
        return {
            "sent": len([r for r in results if not isinstance(r, Exception)]),
            "failed": len([r for r in results if isinstance(r, Exception)])
        }
    
    async def _send_sms(self, phone: str, message: str):
        """發送簡訊"""
        
        # 使用 Twilio 或其他 SMS 服務
        async with aiohttp.ClientSession() as session:
            url = "https://api.twilio.com/2010-04-01/Accounts/{}/Messages.json"
            
            data = {
                "From": self.config["twilio"]["from_number"],
                "To": phone,
                "Body": message
            }
            
            auth = aiohttp.BasicAuth(
                self.config["twilio"]["account_sid"],
                self.config["twilio"]["auth_token"]
            )
            
            async with session.post(url, data=data, auth=auth) as resp:
                return await resp.json()
    
    async def _send_line(self, user_id: str, message: str):
        """發送 LINE 訊息"""
        
        headers = {
            "Authorization": f"Bearer {self.config['line']['channel_token']}",
            "Content-Type": "application/json"
        }
        
        data = {
            "to": user_id,
            "messages": [
                {
                    "type": "text",
                    "text": message
                }
            ]
        }
        
        async with aiohttp.ClientSession() as session:
            url = "https://api.line.me/v2/bot/message/push"
            
            async with session.post(
                url,
                json=data,
                headers=headers
            ) as resp:
                return await resp.json()
    
    async def _send_slack(self, channel: str, message: str):
        """發送 Slack 訊息"""
        
        webhook_url = self.config["slack"]["webhook_url"]
        
        data = {
            "channel": channel,
            "text": message,
            "username": "風險偵測系統",
            "icon_emoji": ":warning:"
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(webhook_url, json=data) as resp:
                return await resp.text()
    
    def _format_crisis_alert(self, event: Dict) -> Dict:
        """格式化危機告警"""
        
        # 簡短版 (SMS)
        sms = f"🚨危機事件 #{event['event_id'][:8]}\n用戶:{event['user_id']}\n等級:{event['level']}\n請立即處理"
        
        # 詳細版 (Email/Slack)
        detailed = f"""
🚨 危機事件通知
================
事件ID: {event['event_id']}
使用者: {event['user_id']}
風險等級: {event['level']}
風險類別: {', '.join(event['categories'])}
時間: {event['timestamp']}

請立即登入系統查看詳情並採取行動。
系統連結: {self.config['system_url']}/crisis/{event['event_id']}
        """
        
        return {
            "sms": sms,
            "detailed": detailed
        }
```

## 7. 風險分析與報表

```python
# analytics/trends.py
from typing import Dict, List
import pandas as pd
from datetime import datetime, timedelta

class RiskAnalytics:
    """風險分析"""
    
    def __init__(self, db_helper):
        self.db = db_helper
    
    async def analyze_user_trends(
        self,
        user_id: str,
        days: int = 30
    ) -> Dict:
        """分析使用者風險趨勢"""
        
        # 查詢歷史風險事件
        events = await self._get_user_risk_events(user_id, days)
        
        if not events:
            return {
                "trend": "no_data",
                "risk_score": 0,
                "recommendations": []
            }
        
        # 轉換為 DataFrame
        df = pd.DataFrame(events)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df.set_index('timestamp', inplace=True)
        
        # 計算趨勢
        analysis = {
            "total_events": len(events),
            "by_level": df['risk_level'].value_counts().to_dict(),
            "by_category": self._flatten_categories(df['categories']),
            "trend": self._calculate_trend(df),
            "peak_times": self._find_peak_times(df),
            "risk_score": self._calculate_risk_score(df),
            "patterns": self._identify_patterns(df)
        }
        
        # 產生建議
        analysis["recommendations"] = self._generate_recommendations(analysis)
        
        return analysis
    
    def _calculate_trend(self, df: pd.DataFrame) -> str:
        """計算趨勢"""
        
        if len(df) < 2:
            return "insufficient_data"
        
        # 將風險等級轉為數值
        level_map = {
            "NONE": 0, "LOW": 1, "MEDIUM": 2,
            "HIGH": 3, "IMMINENT": 4
        }
        
        df['risk_score'] = df['risk_level'].map(level_map)
        
        # 計算移動平均
        df['ma7'] = df['risk_score'].rolling(window=7, min_periods=1).mean()
        
        # 比較最近7天與之前7天
        if len(df) >= 14:
            recent = df['risk_score'][-7:].mean()
            previous = df['risk_score'][-14:-7].mean()
            
            if recent > previous * 1.2:
                return "increasing"
            elif recent < previous * 0.8:
                return "decreasing"
            else:
                return "stable"
        else:
            return "stable"
    
    def _find_peak_times(self, df: pd.DataFrame) -> Dict:
        """找出高風險時段"""
        
        # 按小時分組
        df['hour'] = df.index.hour
        hourly = df.groupby('hour').size()
        
        # 按星期分組
        df['dayofweek'] = df.index.dayofweek
        daily = df.groupby('dayofweek').size()
        
        return {
            "peak_hours": hourly.nlargest(3).index.tolist(),
            "peak_days": daily.nlargest(2).index.tolist()
        }
    
    def _identify_patterns(self, df: pd.DataFrame) -> List[str]:
        """識別風險模式"""
        
        patterns = []
        
        # 檢查是否有週期性
        if len(df) >= 7:
            # 檢查每週模式
            weekly_pattern = df.resample('W').size()
            if weekly_pattern.std() < weekly_pattern.mean() * 0.3:
                patterns.append("weekly_pattern")
        
        # 檢查觸發因子
        categories = self._flatten_categories(df['categories'])
        
        if categories.get("relapse", 0) > len(df) * 0.3:
            patterns.append("relapse_risk")
        
        if categories.get("suicide", 0) > 0:
            patterns.append("suicide_risk")
        
        # 檢查升級模式
        high_risk_events = df[df['risk_level'].isin(['HIGH', 'IMMINENT'])]
        if len(high_risk_events) > len(df) * 0.2:
            patterns.append("frequent_crisis")
        
        return patterns
    
    def _calculate_risk_score(self, df: pd.DataFrame) -> float:
        """計算綜合風險分數 (0-100)"""
        
        level_weights = {
            "NONE": 0, "LOW": 10, "MEDIUM": 30,
            "HIGH": 60, "IMMINENT": 100
        }
        
        # 基礎分數
        base_score = df['risk_level'].map(level_weights).mean()
        
        # 頻率調整
        frequency_factor = min(len(df) / 30, 1.5)  # 最多1.5倍
        
        # 趨勢調整
        trend = self._calculate_trend(df)
        trend_factor = {
            "increasing": 1.2,
            "stable": 1.0,
            "decreasing": 0.8,
            "insufficient_data": 1.0
        }.get(trend, 1.0)
        
        # 計算最終分數
        final_score = base_score * frequency_factor * trend_factor
        
        return min(100, max(0, final_score))
    
    def _generate_recommendations(self, analysis: Dict) -> List[str]:
        """產生建議"""
        
        recommendations = []
        
        # 基於趨勢
        if analysis["trend"] == "increasing":
            recommendations.append("加強監控頻率，考慮主動介入")
        elif analysis["trend"] == "decreasing":
            recommendations.append("維持現有支持策略，持續觀察")
        
        # 基於模式
        patterns = analysis.get("patterns", [])
        
        if "suicide_risk" in patterns:
            recommendations.append("安排專業心理評估")
            recommendations.append("確保24小時危機支援可及性")
        
        if "relapse_risk" in patterns:
            recommendations.append("加強戒癮支持小組參與")
            recommendations.append("評估藥物治療方案")
        
        if "frequent_crisis" in patterns:
            recommendations.append("考慮住院或密集門診治療")
            recommendations.append("建立危機應變計劃")
        
        # 基於風險分數
        risk_score = analysis["risk_score"]
        
        if risk_score > 70:
            recommendations.append("立即安排個案會議")
        elif risk_score > 40:
            recommendations.append("增加諮詢頻率")
        
        # 基於高風險時段
        peak_hours = analysis.get("peak_times", {}).get("peak_hours", [])
        if peak_hours:
            recommendations.append(
                f"在高風險時段加強支持: {peak_hours}"
            )
        
        return recommendations
```

## 8. 測試與驗證

```python
# test_risk_detection.py
import unittest
from datetime import datetime

class TestRiskDetection(unittest.TestCase):
    
    def setUp(self):
        self.keyword_detector = KeywordDetector()
        self.ml_classifier = MLRiskClassifier()
        self.context_detector = ContextAwareDetector()
    
    def test_suicide_keyword_detection(self):
        """測試自殺關鍵字偵測"""
        
        test_cases = [
            ("我想結束自己的生命", RiskLevel.HIGH),
            ("活著好累，不想繼續了", RiskLevel.MEDIUM),
            ("今天心情不太好", RiskLevel.NONE)
        ]
        
        for text, expected_level in test_cases:
            indicators = self.keyword_detector.detect(text, "zh-TW")
            
            if expected_level == RiskLevel.NONE:
                self.assertEqual(len(indicators), 0)
            else:
                self.assertTrue(len(indicators) > 0)
                max_level = max(i.level for i in indicators)
                self.assertEqual(max_level, expected_level)
    
    def test_ml_classification(self):
        """測試 ML 分類器"""
        
        text = "我真的撐不下去了，想要一了百了"
        result = self.ml_classifier.predict(text)
        
        self.assertIn(result["level"], [RiskLevel.HIGH, RiskLevel.IMMINENT])
        self.assertGreater(result["confidence"], 0.7)
    
    def test_context_awareness(self):
        """測試上下文感知"""
        
        # 模擬對話歷史
        conversation_id = "test_conv_1"
        user_id = "test_user_1"
        
        # 第一則訊息 - 低風險
        assessment1 = self.context_detector.analyze_with_context(
            "我今天感覺有點低落",
            conversation_id,
            user_id,
            {"stage": "treatment", "days_in_treatment": 15}
        )
        
        self.assertEqual(assessment1.overall_level, RiskLevel.LOW)
        
        # 第二則訊息 - 風險升級
        assessment2 = self.context_detector.analyze_with_context(
            "越來越糟了，我不知道還能撐多久",
            conversation_id,
            user_id,
            {"stage": "treatment", "days_in_treatment": 15}
        )
        
        # 應該偵測到升級趨勢
        self.assertGreaterEqual(
            assessment2.overall_level.value,
            assessment1.overall_level.value
        )
    
    def test_crisis_handling(self):
        """測試危機處理"""
        
        # 模擬高風險評估
        assessment = RiskAssessment(
            overall_level=RiskLevel.IMMINENT,
            categories=[RiskCategory.SUICIDE],
            indicators=[
                RiskIndicator(
                    category=RiskCategory.SUICIDE,
                    level=RiskLevel.IMMINENT,
                    confidence=0.95,
                    evidence=["keyword:自殺"],
                    recommended_action="立即介入"
                )
            ],
            timestamp=datetime.utcnow(),
            context={},
            intervention_required=True
        )
        
        handler = CrisisHandler(None, None)
        
        # 測試資源生成
        resources = handler._get_crisis_resources([RiskCategory.SUICIDE])
        
        self.assertIn("hotlines", resources)
        self.assertIn("emergency", resources)
        self.assertTrue(len(resources["hotlines"]) > 0)
    
    def test_multilingual_detection(self):
        """測試多語言支援"""
        
        test_cases = [
            ("I want to kill myself", "en", RiskLevel.HIGH),
            ("我想自殺", "zh-TW", RiskLevel.HIGH),
            ("Tôi muốn tự tử", "vi", RiskLevel.HIGH)  # 越南語
        ]
        
        for text, lang, expected_level in test_cases:
            indicators = self.keyword_detector.detect(text, lang)
            # 實際實作需要支援多語言
            pass

if __name__ == "__main__":
    unittest.main()
```

## 關鍵記憶點
1. **必須**實作雙層檢測 (規則+ML) 確保準確性
2. **記得**考慮上下文和歷史趨勢
3. **注意**不同風險等級需要不同處理協議
4. **重要**高風險事件必須即時通知且多通道確保送達